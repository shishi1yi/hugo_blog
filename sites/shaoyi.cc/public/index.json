[{"content":"项目打包到Maven 私服 配置Maven 配置私服仓库的用户和密码\n在maven安装目录 /conf/setting.xml 中的servers下添加 \u0026lt;servers\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;nexus-snapshots\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;123456\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;nexus-releases\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;123456\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;/servers\u0026gt; 在需要打包的maven模块中，配置pom文件内容 在maven工程的pom.xml配置部署的仓库，注意pom.xml和setting.xml中的id属性要一致\n\u0026lt;!-- 发布maven私服 --\u0026gt; \u0026lt;distributionManagement\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;nexus-snapshots\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;shishiyi-framework-SNAPSHOTS\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:30010/repository/3rd-part/\u0026lt;/url\u0026gt; // 私服仓库对应的url \u0026lt;/repository\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;id\u0026gt;nexus-repository\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;shishiyi-framework-REPOSITORY\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:30010/repository/3rd-part/\u0026lt;/url\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;/distributionManagement\u0026gt; 使用deploy命令上传 mvn source:jar deploy -Dmaven.test.skip=true\n项目获取私服仓库中的包 在项目根部的pom文件中添加下列内容\n\u0026lt;!-- 远程nexus仓库 --\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;nexus-snapshots\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:30010/repository/3rd-part/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;nexus-repository\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:30010/repository/3rd-part/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;pluginRepositories\u0026gt; \u0026lt;pluginRepository\u0026gt; \u0026lt;id\u0026gt;nexus-snapshots\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:30010/repository/3rd-part/\u0026lt;/url\u0026gt; \u0026lt;/pluginRepository\u0026gt; \u0026lt;pluginRepository\u0026gt; \u0026lt;id\u0026gt;nexus-repository\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:30010/repository/3rd-part/\u0026lt;/url\u0026gt; \u0026lt;/pluginRepository\u0026gt; \u0026lt;/pluginRepositories\u0026gt; ","permalink":"http://shaoyi.cc/posts/blog/maven%E7%A7%81%E6%9C%8D/maven-%E7%A7%81%E6%9C%8D/","summary":"项目打包到Maven 私服 配置Maven 配置私服仓库的用户和密码 在maven安装目录 /conf/setting.xml 中的servers下添加 \u0026lt;servers\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;nexus-snapshots\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;123456\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;nexus-releases\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;123456\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;/servers\u0026gt; 在需要打","title":"Maven 私服"},{"content":"Jenkins构建 前端构建 创建一个【自由风格】的任务 点击【源码管理】 填写（选择）项目仓库的地址和用户\n指定要构建的版本，即项目仓库的远程版本号\n选择nodejs版本 如果没有选项，说明当前jenkins 没有安装\n填写构建的命令 这个命令取决于具体工程，和本地第一次执行命令基本一致\n例如：node -v \u0026amp;\u0026amp; npm install -g yarn@1.22.19 \u0026amp;\u0026amp; yarn -v \u0026amp;\u0026amp; yarn install \u0026ndash;pure-lockfile \u0026amp;\u0026amp; yarn run build \u0026amp;\u0026amp; cd dist \u0026amp;\u0026amp; tar -zcvf dist.tar.gz *\n上述例子意思大致为，获取项目依赖，并打包构建，然后把打好的包压缩\n传输打包的文件到指定服务器 【SSH Server】：选择要传输文件的服务器\nTransfers\n【Source files】：写你要传输的文件路径 【Remove prefix】：要去掉的前缀，不写远程服务器的目录结构将和Source files写的一致 【Remote directory】：写你要部署在远程服务器的那个目录地址下，不写就是SSH Servers配置里默认远程目录 【Exec command】：传输完了要执行的命令，图中例子是 进入目录,解压缩,解压缩完成后删除压缩包三个命令 后端构建 创建maven任务 任务的全局设置 指定jdk版本 点击【源码管理】 填写（选择）项目仓库的地址和用户\n指定要构建的版本，即项目仓库的远程版本号\n构建时，指定pom文件 跳过测试构建（非必须） 设置只用构建成功的包 传输打包的文件到指定服务器 【SSH Server】：选择要传输文件的服务器\nTransfers\n【Source files】：写你要传输的文件路径 【Remove prefix】：要去掉的前缀，不写远程服务器的目录结构将和Source files写的一致 【Remote directory】：写你要部署在远程服务器的那个目录地址下，不写就是SSH Servers配置里默认远程目录 【Exec command】：传输完了要执行的命令 Jenkins自动化构建（钩子） 设置触发自动化构建的条件 下图框中部分为触发自动构建的条件，本例子触发条件的为【提交事件】\n设置分支过滤 本例没有做限制\nGitLab设置 复制URL\n点击Generate按钮，token就会自动生成Secret token\nURL和Secret token，设置在对应的仓库中 测试 GitLab页面提示下图内容，则成功触发Jenkins构建任务 Jenkins构建历史已有记录 项目配置私服 仓库setting.xml文件配置私服用户密码 由于jenkins是docker部署的，会牵扯到一个访问地址\n如果是本地获取私服包，则需要在项目的根部pom.xml 配置私服地址 注：id要和setting.xml文件中一致\n如果是Jenkins构建，则需要把项目的根部pom.xml 改成下图中的ip\n","permalink":"http://shaoyi.cc/posts/blog/jenkins%E6%9E%84%E5%BB%BA/jenkins-%E6%9E%84%E5%BB%BA/","summary":"Jenkins构建 前端构建 创建一个【自由风格】的任务 点击【源码管理】 填写（选择）项目仓库的地址和用户 指定要构建的版本，即项目仓库的远程版本号","title":"Jenkins部署"},{"content":"关于我\n","permalink":"http://shaoyi.cc/about/","summary":"关于我","title":"🙋🏻‍♂️关于"},{"content":"Docker安装步骤 安装Docker 安装\n帮助文档：\n# yum安装gcc相关环境（需要确保 虚拟机可以上外网 ） yum -y install gcc yum -y install gcc-c++ #1、卸载旧的Docker版本 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine #2、需要的安装包 yum install -y yum-utils #更新yum软件包索引 yum makecache fast #3、设置镜像的仓库 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo #默认是国外的镜像，速度比较慢 yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #阿里云的镜像地址安装(推荐使用国内的镜像) #4、安装Docker docker-ce 社区版 ee 企业版 yum install docker-ce docker-ce-cli containerd.io #5、启用Docker systemctl start docker #6、查看是否安装成功 docker version #7、hello-world docker run hello-world #8、查看一下 下载的这个hello-world镜像 [root@shishiyi /]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 8 months ago 13.3kB 了解：如何卸载Docker\n#1、卸载docker的依赖 yum remove docker-ce docker-ce-cli containerd.io #2、删除资源 rm -rf /var/lib/docker #\t/var/lib/docker 为docker的默认工作路径 阿里云镜像加速 1、找到阿里云的【容器镜像服务】——\u0026gt;【镜像中心】——\u0026gt;【镜像加速器】\n2、选择对应的系统配置使用\nsudo mkdir -p /etc/docker\t#创建目录并在目录下加入镜像配置 sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39;\t{ \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://rksuvr7q.mirror.aliyuncs.com\u0026#34;] } EOF sudo systemctl daemon-reload\t#重启镜像 sudo systemctl restart docker\t#重启Docker Docker常用命令 帮助命令 docker version\t#显示docker的版本信息 docker info\t#显示docker的系统信息，包括镜像和容器的数量 docker 命令 --help #帮助命令 帮助文档链接：https://docs.docker.com/reference/\n镜像命令 docker images 查看所有本地的主机上的镜像\n[root@shishiyi ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 8 months ago 13.3kB #解释 REPOSITORY 镜像的仓库源（即名字） TAG\t镜像的标签 IMAGE ID\t镜像的id CREATED 镜像的创建时间 SIZE\t镜像的大小 #可选项 -a, --all # 列出所有镜像 -q, --quiet # 只显示镜像的id docker search\t搜索镜像\n[root@shishiyi ~]# docker search mysql NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 9918 [OK] mariadb MariaDB is a community-developed fork of MyS… 3629 [OK] #可选项 搜索过滤 --filter=STARS=3000\t#表示搜索出来的镜像为STARS大于3000的 [root@shishiyi ~]# docker search mysql --filter=STARS=3000 NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 9918 [OK] mariadb MariaDB is a community-developed fork of MyS… 3629 [OK] [root@shishiyi ~]# docker search mysql --filter=STARS=4000 NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 9918 [OK] docker pull\t下载镜像\n#下载镜像 docker pull 镜像名称:[tag] [root@shishiyi ~]# docker pull mysql Using default tag: latest\t#如果不写tag,即版本号，默认就是latest latest: Pulling from library/mysql bf5952930446: Pull complete #分层下载，docker images的核心 联合文件系统 8254623a9871: Pull complete 938e3e06dac4: Pull complete ea28ebf28884: Pull complete f3cef38785c2: Pull complete 894f9792565a: Pull complete 1d8a57523420: Pull complete 6c676912929f: Pull complete ff39fdb566b4: Pull complete fff872988aba: Pull complete 4d34e365ae68: Pull complete 7886ee20621e: Pull complete Digest: sha256:c358e72e100ab493a0304bda35e6f239db2ec8c9bb836d8a427ac34307d074ed\t#签名 Status: Downloaded newer image for mysql:latest\tdocker.io/library/mysql:latest\t#真实地址 #等价于它 docker pull mysql docker pull docker.io/library/mysql:latest #指定版本下载 [root@shishiyi ~]# docker pull mysql:5.7 5.7: Pulling from library/mysql bf5952930446: Already exists 8254623a9871: Already exists 938e3e06dac4: Already exists ea28ebf28884: Already exists f3cef38785c2: Already exists 894f9792565a: Already exists 1d8a57523420: Already exists 5f09bf1d31c1: Pull complete 1b6ff254abe7: Pull complete 74310a0bf42d: Pull complete d398726627fd: Pull complete Digest: sha256:da58f943b94721d46e87d5de208dc07302a8b13e638cd1d24285d222376d6d84 Status: Downloaded newer image for mysql:5.7 docker.io/library/mysql:5.7 docker rmi 删除镜像\n[root@shishiyi ~]# docker rmi -f 镜像id\t#删除指定镜像 [root@shishiyi ~]# docker rmi -f 镜像id 镜像id 镜像id 镜像id\t#删除多个镜像id\t[root@shishiyi ~]# docker rmi -f $(docker images -aq)\t#删除全部镜像 容器命令 有镜像才能创建容器，Linux下载一个centos测试\ndocker pull centos 新建容器并启动\ndocker run [可选参数] image # 参数说明 --name=\u0026#34;Name\u0026#34;\t容器名字 ，用来区分容器 -d\t后台方式运行 -it\t使用交互方式运行，进入容器查看内容 -p(小写)\t指定容器的端口，例如 -p 8080:8080 -p ip:主机端口：容器端口 -p 主机端口：容器端口（常用） -p 容器端口 容器端口 -P(大写) 随机指定端口 #测试，启动进入容器 [root@shishiyi ~]# docker run -it centos /bin/bash [root@17e6da9a3c45 /]# ls\t#查看容器内的centos,基础版，很多命令不完善的 bin etc lib\tlost+found mnt proc run srv tmp var dev home lib64 media opt root sbin sys usr 列出所有运行的容器\n#docker ps 命令 列出当前正在运行的容器 -a\t#列出运行过和正在运行的容器 -n=? #列出最近创建的容器 -q\t#只显示容器的编号 [root@shishiyi ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@shishiyi ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 17e6da9a3c45 centos \u0026#34;/bin/bash\u0026#34; 3 minutes ago Exited (127) 46 seconds ago relaxed_babbage f8decff51b25 bf756fb1ae65 \u0026#34;/hello\u0026#34; 18 hours ago Exited (0) 18 hours ago boring_curran 退出容器\nexit # 退出容器并停止 Ctrl + P + Q #退出容器且不停止 删除容器\ndocker rm 容器id\t#删除指定容器，不能删除正在运行的容器，如果强制删除 rm -f docker rm -f $(docker ps -aq)\t#删除所有容器 docker ps -a -q|xargs docker rm\t#删除所有容器 启动和停止容器\ndocker start 容器id\t#启动指定容器 docker restart 容器id\t#重启指定容器 docker stop 容器id\t#停止当前正在运行指定容器 docker kill 容器id\t#强制停止当前指定容器 其它常用命令 查看日志\n#命令 docker logs -f -t --tail 容器id #[root@shishiyi /]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS 5c97ab1298f8 centos \u0026#34;/bin/bash\u0026#34; 6 minutes ago Up 6 minutes #例如 -tf\t#显示日志 --tail number\t#要是显示的日志条数 [root@shishiyi ~]# docker logs -tf --tail 10 5c97ab1298f8 查看容器中进程信息\n# 命令 docker top 容器id #例如 [root@shishiyi /]# docker top 5c97ab1298f8 UID PID PPID C STIME TTY TIME root 16042 16018 0 15:27 pts/0 00:00:00 查看镜像的元数据\n#命令 docker inspect 容器id #测试 [root@shishiyi /]# docker inspect 5c97ab1298f8 [ { \u0026#34;Id\u0026#34;: \u0026#34;5c97ab1298f8820d95e8cda27ea9156e5c249ad2d90ade5d7a3d064401bf8ecb\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2020-09-01T07:27:36.571377434Z\u0026#34;, \u0026#34;Path\u0026#34;: \u0026#34;/bin/bash\u0026#34;, \u0026#34;Args\u0026#34;: [], \u0026#34;State\u0026#34;: { \u0026#34;Status\u0026#34;: \u0026#34;running\u0026#34;, \u0026#34;Running\u0026#34;: true, \u0026#34;Paused\u0026#34;: false, \u0026#34;Restarting\u0026#34;: false, \u0026#34;OOMKilled\u0026#34;: false, \u0026#34;Dead\u0026#34;: false, \u0026#34;Pid\u0026#34;: 16042, \u0026#34;ExitCode\u0026#34;: 0, \u0026#34;Error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;StartedAt\u0026#34;: \u0026#34;2020-09-01T07:27:36.940479781Z\u0026#34;, \u0026#34;FinishedAt\u0026#34;: \u0026#34;0001-01-01T00:00:00Z\u0026#34; }, \u0026#34;Image\u0026#34;: \u0026#34;sha256:0d120b6ccaa8c5e149176798b3501d4dd1885f961922497cd0abef155c869566\u0026#34;, \u0026#34;ResolvConfPath\u0026#34;: \u0026#34;/var/lib/docker/containers/5c97ab1298f8820d95e8cda27ea9156e5c249ad2d90ade5d7a3d064401bf8ecb/resolv.conf\u0026#34;, \u0026#34;HostnamePath\u0026#34;: \u0026#34;/var/lib/docker/containers/5c97ab1298f8820d95e8cda27ea9156e5c249ad2d90ade5d7a3d064401bf8ecb/hostname\u0026#34;, \u0026#34;HostsPath\u0026#34;: \u0026#34;/var/lib/docker/containers/5c97ab1298f8820d95e8cda27ea9156e5c249ad2d90ade5d7a3d064401bf8ecb/hosts\u0026#34;, \u0026#34;LogPath\u0026#34;: \u0026#34;/var/lib/docker/containers/5c97ab1298f8820d95e8cda27ea9156e5c249ad2d90ade5d7a3d064401bf8ecb/5c97ab1298f8820d95e8cda27ea9156e5c249ad2d90ade5d7a3d064401bf8ecb-json.log\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;/nifty_margulis\u0026#34;, \u0026#34;RestartCount\u0026#34;: 0, \u0026#34;Driver\u0026#34;: \u0026#34;overlay2\u0026#34;, \u0026#34;Platform\u0026#34;: \u0026#34;linux\u0026#34;, \u0026#34;MountLabel\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;ProcessLabel\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;AppArmorProfile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;ExecIDs\u0026#34;: null, \u0026#34;HostConfig\u0026#34;: { \u0026#34;Binds\u0026#34;: null, \u0026#34;ContainerIDFile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;LogConfig\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;Config\u0026#34;: {} }, \u0026#34;NetworkMode\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;PortBindings\u0026#34;: {}, \u0026#34;RestartPolicy\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;no\u0026#34;, \u0026#34;MaximumRetryCount\u0026#34;: 0 }, \u0026#34;AutoRemove\u0026#34;: false, \u0026#34;VolumeDriver\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;VolumesFrom\u0026#34;: null, \u0026#34;CapAdd\u0026#34;: null, \u0026#34;CapDrop\u0026#34;: null, \u0026#34;Capabilities\u0026#34;: null, \u0026#34;Dns\u0026#34;: [], \u0026#34;DnsOptions\u0026#34;: [], \u0026#34;DnsSearch\u0026#34;: [], \u0026#34;ExtraHosts\u0026#34;: null, \u0026#34;GroupAdd\u0026#34;: null, \u0026#34;IpcMode\u0026#34;: \u0026#34;private\u0026#34;, \u0026#34;Cgroup\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Links\u0026#34;: null, \u0026#34;OomScoreAdj\u0026#34;: 0, \u0026#34;PidMode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Privileged\u0026#34;: false, \u0026#34;PublishAllPorts\u0026#34;: false, \u0026#34;ReadonlyRootfs\u0026#34;: false, \u0026#34;SecurityOpt\u0026#34;: null, \u0026#34;UTSMode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;UsernsMode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;ShmSize\u0026#34;: 67108864, \u0026#34;Runtime\u0026#34;: \u0026#34;runc\u0026#34;, \u0026#34;ConsoleSize\u0026#34;: [ 0, 0 ], \u0026#34;Isolation\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;CpuShares\u0026#34;: 0, \u0026#34;Memory\u0026#34;: 0, \u0026#34;NanoCpus\u0026#34;: 0, \u0026#34;CgroupParent\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;BlkioWeight\u0026#34;: 0, \u0026#34;BlkioWeightDevice\u0026#34;: [], \u0026#34;BlkioDeviceReadBps\u0026#34;: null, \u0026#34;BlkioDeviceWriteBps\u0026#34;: null, \u0026#34;BlkioDeviceReadIOps\u0026#34;: null, \u0026#34;BlkioDeviceWriteIOps\u0026#34;: null, \u0026#34;CpuPeriod\u0026#34;: 0, \u0026#34;CpuQuota\u0026#34;: 0, \u0026#34;CpuRealtimePeriod\u0026#34;: 0, \u0026#34;CpuRealtimeRuntime\u0026#34;: 0, \u0026#34;CpusetCpus\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;CpusetMems\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Devices\u0026#34;: [], \u0026#34;DeviceCgroupRules\u0026#34;: null, \u0026#34;DeviceRequests\u0026#34;: null, \u0026#34;KernelMemory\u0026#34;: 0, \u0026#34;KernelMemoryTCP\u0026#34;: 0, \u0026#34;MemoryReservation\u0026#34;: 0, \u0026#34;MemorySwap\u0026#34;: 0, \u0026#34;MemorySwappiness\u0026#34;: null, \u0026#34;OomKillDisable\u0026#34;: false, \u0026#34;PidsLimit\u0026#34;: null, \u0026#34;Ulimits\u0026#34;: null, \u0026#34;CpuCount\u0026#34;: 0, \u0026#34;CpuPercent\u0026#34;: 0, \u0026#34;IOMaximumIOps\u0026#34;: 0, \u0026#34;IOMaximumBandwidth\u0026#34;: 0, \u0026#34;MaskedPaths\u0026#34;: [ \u0026#34;/proc/asound\u0026#34;, \u0026#34;/proc/acpi\u0026#34;, \u0026#34;/proc/kcore\u0026#34;, \u0026#34;/proc/keys\u0026#34;, \u0026#34;/proc/latency_stats\u0026#34;, \u0026#34;/proc/timer_list\u0026#34;, \u0026#34;/proc/timer_stats\u0026#34;, \u0026#34;/proc/sched_debug\u0026#34;, \u0026#34;/proc/scsi\u0026#34;, \u0026#34;/sys/firmware\u0026#34; ], \u0026#34;ReadonlyPaths\u0026#34;: [ \u0026#34;/proc/bus\u0026#34;, \u0026#34;/proc/fs\u0026#34;, \u0026#34;/proc/irq\u0026#34;, \u0026#34;/proc/sys\u0026#34;, \u0026#34;/proc/sysrq-trigger\u0026#34; ] }, \u0026#34;GraphDriver\u0026#34;: { \u0026#34;Data\u0026#34;: { \u0026#34;LowerDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/59787dd31a270bf3606b8f7960f91eb54aaf5926b0c940b32bc7488ac4a91edc-init/diff:/var/lib/docker/overlay2/cfd05b0bbde49a9a0c58c89767084e493d0b018ef3c1bc0220a022015610b97a/diff\u0026#34;, \u0026#34;MergedDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/59787dd31a270bf3606b8f7960f91eb54aaf5926b0c940b32bc7488ac4a91edc/merged\u0026#34;, \u0026#34;UpperDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/59787dd31a270bf3606b8f7960f91eb54aaf5926b0c940b32bc7488ac4a91edc/diff\u0026#34;, \u0026#34;WorkDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/59787dd31a270bf3606b8f7960f91eb54aaf5926b0c940b32bc7488ac4a91edc/work\u0026#34; }, \u0026#34;Name\u0026#34;: \u0026#34;overlay2\u0026#34; }, \u0026#34;Mounts\u0026#34;: [], \u0026#34;Config\u0026#34;: { \u0026#34;Hostname\u0026#34;: \u0026#34;5c97ab1298f8\u0026#34;, \u0026#34;Domainname\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;User\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;AttachStdin\u0026#34;: true, \u0026#34;AttachStdout\u0026#34;: true, \u0026#34;AttachStderr\u0026#34;: true, \u0026#34;Tty\u0026#34;: true, \u0026#34;OpenStdin\u0026#34;: true, \u0026#34;StdinOnce\u0026#34;: true, \u0026#34;Env\u0026#34;: [ \u0026#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34; ], \u0026#34;Cmd\u0026#34;: [ \u0026#34;/bin/bash\u0026#34; ], \u0026#34;Image\u0026#34;: \u0026#34;centos\u0026#34;, \u0026#34;Volumes\u0026#34;: null, \u0026#34;WorkingDir\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Entrypoint\u0026#34;: null, \u0026#34;OnBuild\u0026#34;: null, \u0026#34;Labels\u0026#34;: { \u0026#34;org.label-schema.build-date\u0026#34;: \u0026#34;20200809\u0026#34;, \u0026#34;org.label-schema.license\u0026#34;: \u0026#34;GPLv2\u0026#34;, \u0026#34;org.label-schema.name\u0026#34;: \u0026#34;CentOS Base Image\u0026#34;, \u0026#34;org.label-schema.schema-version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;org.label-schema.vendor\u0026#34;: \u0026#34;CentOS\u0026#34; } }, \u0026#34;NetworkSettings\u0026#34;: { \u0026#34;Bridge\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;SandboxID\u0026#34;: \u0026#34;24dac8793fce9c49029e6f472af4e01bc23c25af31fbc8d16ce60075ad9b8b33\u0026#34;, \u0026#34;HairpinMode\u0026#34;: false, \u0026#34;LinkLocalIPv6Address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;LinkLocalIPv6PrefixLen\u0026#34;: 0, \u0026#34;Ports\u0026#34;: {}, \u0026#34;SandboxKey\u0026#34;: \u0026#34;/var/run/docker/netns/24dac8793fce\u0026#34;, \u0026#34;SecondaryIPAddresses\u0026#34;: null, \u0026#34;SecondaryIPv6Addresses\u0026#34;: null, \u0026#34;EndpointID\u0026#34;: \u0026#34;51415885283d49663fb7ca11668b55ad10d433dbe170e5a0699f05f77bd5b5df\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34;, \u0026#34;GlobalIPv6Address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;GlobalIPv6PrefixLen\u0026#34;: 0, \u0026#34;IPAddress\u0026#34;: \u0026#34;172.17.0.2\u0026#34;, \u0026#34;IPPrefixLen\u0026#34;: 16, \u0026#34;IPv6Gateway\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:02\u0026#34;, \u0026#34;Networks\u0026#34;: { \u0026#34;bridge\u0026#34;: { \u0026#34;IPAMConfig\u0026#34;: null, \u0026#34;Links\u0026#34;: null, \u0026#34;Aliases\u0026#34;: null, \u0026#34;NetworkID\u0026#34;: \u0026#34;927dcbdbe869574ba0ba3e6e0bf4012f1b67fe1f2d1f4846d8da44c96afe0d2f\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;51415885283d49663fb7ca11668b55ad10d433dbe170e5a0699f05f77bd5b5df\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34;, \u0026#34;IPAddress\u0026#34;: \u0026#34;172.17.0.2\u0026#34;, \u0026#34;IPPrefixLen\u0026#34;: 16, \u0026#34;IPv6Gateway\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;GlobalIPv6Address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;GlobalIPv6PrefixLen\u0026#34;: 0, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:02\u0026#34;, \u0026#34;DriverOpts\u0026#34;: null } } } } ] 进入当前正在运行的容器\n#命令 docker exec -it 容器id bashShell #测试 [root@shishiyi /]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS 5c97ab1298f8 centos \u0026#34;/bin/bash\u0026#34; 10 minutes ago Up 10 minutes [root@shishiyi /]# docker exec -it 5c97ab1298f8 /bin/bash [root@5c97ab1298f8 /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var #方式二 #命令 docker attach 容器id #测试 [root@shishiyi /]# docker attach 5c97ab1298f8 正在执行的代码....... #docker exec 是进入容器后重新开启一个终端，可以在容器里操作 #docker attach 是进入容器正在执行的终端，不会启用新的进程！ 从容器内拷贝文件到主机上\n#命令 docker cp 容器id:容器内路径 目的的主机路径 commit镜像 docker commit\t提交容器成为一个新的副本 #命令和git原理类似 docker commit -m=\u0026#34;提交的描述信息\u0026#34; -a=\u0026#34;作者\u0026#34; 容器id 目标镜像名称:[TAG] 实战测试\n#1、启动一个默认的tomcat容器 #2、发现默认tomcat容器是没有webapps应用的， 镜像的原因，官方的镜像默认webapps下面是没有文件的 #3、自己拷贝基本文件到webapps下 #4、然后将上述操作后的tomcat容器提交为一个镜像！之后便可以使用这个新建的镜像创建容器 容器数据卷 方式一：直接使用命令来挂载 -v\ndocker run -it -v 主机目录:容器内的目录 #启动起来时候我们可以通过docker inspect 容器id 来查看挂载的目录 具名挂载和匿名挂载 #匿名挂载 -v 容器内路径 #-v后面只写了容器内的路径，没有写主机路径，这种就是匿名挂载 #具名挂载 -v 卷名:容器内路径 #-v后面只写了一个名字，而不是具体的主机目录，然后加上容器内路径，这种就是具名挂载 所有的docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxxx/_data\n我们通过具名挂载可以方便找到我们的一个卷，大多数情况是使用具名挂载\n#如何确定是具名挂载还是匿名挂载，还是指定路径挂载 -v 容器内路径\t#匿名挂载 -v 卷名:容器内路径\t#具名挂载 -v /宿主机路径:容器内路径 #指定路径挂载 拓展\n#\t通过 -v 容器内路径：ro rw 改变读写权限 ro\treadonly\t#只读 rw\treadwrite\t#可读可写 #\t一旦这个设置了容器权限，容器对我们挂载出来的内容就有了限定！ docker run -d -P --name nginx01 -v juming-nginx:/etc/nginx:ro nginx docker run -d -P --name nginx01 -v juming-nginx:/etc/nginx:rw nginx #ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！ DockerFile构建镜像 DockerFile指令 FROM\t#\t基础镜像，一切从这里开始构建 MAINEAINER\t#\t镜像是谁写的，姓名+邮箱，譬如 shishiyi\u0026lt;shaoyi.o@qq.com\u0026gt; RUN\t#\t镜像构建的时候需要运行的命令 ADD\t#\t添加文件 WORKDIR\t#\t镜像的工作目录 VOLUME\t#\t挂载的目录 EXPOSE #\t镜像暴露的端口 CMD\t# 指定这个容器启动的时候要运行的命令，在用run命令启动容器追加命令会被替换掉 ENTRYPOINT\t#\t指定这个容器启动的时候要运行的命令，可以在run命令启动容器追加命令 ONBUILD\t#\t当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD 的指令。触发命令 COPY\t#\t类似ADD，将我们文件拷贝到镜像中 ENV\t#\t构建的时候设置环境变量 LABEL\t#\t设置镜像的标签 实战测试DockerFile指令 # 1、编写一个自己的centos的DockerFile文件 [root@shishiyi mydockerfile]# cat mydockerfile-centos FROM centos MAINTAINER shishiyi\u0026lt;shaoyi.0@qq.com\u0026gt; ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \u0026#34;----end----\u0026#34; CMD /bin/bash # 2、通过自己写的dockerfile文件构建镜像 #命令: docker build -f dockerfile文件路径 -t 镜像名:[tag] . #命令结尾一定要加空格和点 [root@shishiyi mydockerfile]# docker build -f mydockerfile-centos -t mycentos:0.1 . ......(中间省略) Successfully built 09aaf2b838b6 Successfully tagged mycentos:0.1 对比 原生的centos\n通过自己写的DockerFile文件构建镜像的centos\n# 可以通过命令列出一个镜像是怎么生成的，即dockerfile的命令 #命令： docker history 镜像id CMD和ENTRYPOINT的区别\nCMD #这个是指容器启动时要执行的命令，如果在docker run后加了命令则会覆盖CMD指令 ENTRYPOINT #这个也是容器启动时要执行的命令，使用docker run 命令启动包含ENTRYPOINT的容器，指定会作为参数传递 #如果确实有需要，也可以在运行容器时通过docker run --entrypoint 覆盖ENTRYPOINT指令 实战测试两者区别\n测试CMD\n#\t1、 编写dockerfile文件 [root@shishiyi mydockerfile]# vim mydockerfile-centos-cmdtest FROM centos CMD [\u0026#34;ls\u0026#34;,\u0026#34;-a\u0026#34;] #\t2、构建镜像 [root@shishiyi mydockerfile]# docker build -f mydockerfile-centos-cmdtest -t centos-cmd-test:0.1 . Sending build context to Docker daemon 3.072kB Step 1/2 : FROM centos ---\u0026gt; 0d120b6ccaa8 Step 2/2 : CMD [\u0026#34;ls\u0026#34;,\u0026#34;-a\u0026#34;] ---\u0026gt; Running in d7ee5073447a Removing intermediate container d7ee5073447a ---\u0026gt; adc267054d89 Successfully built adc267054d89 Successfully tagged centos-cmd-test:0.1 #\t3、启动容器，发现ls -a命令生效了 [root@shishiyi mydockerfile]# docker run centos-cmd-test:0.1 . .. .dockerenv bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var #想追加一个命令 -l 变成ls -al [root@shishiyi mydockerfile]# docker run centos-cmd-test:0.1 -l docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused \u0026#34;exec: \\\u0026#34;-l\\\u0026#34;: executable file not found in $PATH\u0026#34;: unknown. #CMD情况下 -l却把CMD[\u0026#34;ls\u0026#34;, \u0026#34;-a\u0026#34;]指令替换了，导致不是命令报错 测试ENTRYPOINT指令\n# 编写dockerfile文件 [root@shishiyi mydockerfile]# vim mydockerfile-centos-entrypointtest FROM centos ENTRYPOINT [\u0026#34;ls\u0026#34;,\u0026#34;-a\u0026#34;] # 构建镜像 [root@shishiyi mydockerfile]# docker build -f mydockerfile-centos-entrypointtest -t centos-entrypoint-test:0.1 . Sending build context to Docker daemon 4.096kB Step 1/2 : FROM centos ---\u0026gt; 0d120b6ccaa8 Step 2/2 : ENTRYPOINT [\u0026#34;ls\u0026#34;,\u0026#34;-a\u0026#34;] ---\u0026gt; Running in 936e7ec1e16c Removing intermediate container 936e7ec1e16c ---\u0026gt; 68dbcdfd80a6 Successfully built 68dbcdfd80a6 Successfully tagged centos-entrypoint-test:0.1 # 启动容器 [root@shishiyi mydockerfile]# docker run centos-entrypoint-test:0.1 . .. .dockerenv bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var #启动容器追加一个命令 -l ,发现直接拼接在了ENTRYPOINT [\u0026#34;ls\u0026#34;,\u0026#34;-a\u0026#34;]指令后面 [root@shishiyi mydockerfile]# docker run centos-entrypoint-test:0.1 -l total 56 drwxr-xr-x 1 root root 4096 Sep 8 04:03 . drwxr-xr-x 1 root root 4096 Sep 8 04:03 .. -rwxr-xr-x 1 root root 0 Sep 8 04:03 .dockerenv lrwxrwxrwx 1 root root 7 May 11 2019 bin -\u0026gt; usr/bin drwxr-xr-x 5 root root 340 Sep 8 04:03 dev drwxr-xr-x 1 root root 4096 Sep 8 04:03 etc drwxr-xr-x 2 root root 4096 May 11 2019 home lrwxrwxrwx 1 root root 7 May 11 2019 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 May 11 2019 lib64 -\u0026gt; usr/lib64 drwx------ 2 root root 4096 Aug 9 21:40 lost+found drwxr-xr-x 2 root root 4096 May 11 2019 media drwxr-xr-x 2 root root 4096 May 11 2019 mnt drwxr-xr-x 2 root root 4096 May 11 2019 opt dr-xr-xr-x 94 root root 0 Sep 8 04:03 proc dr-xr-x--- 2 root root 4096 Aug 9 21:40 root drwxr-xr-x 11 root root 4096 Aug 9 21:40 run lrwxrwxrwx 1 root root 8 May 11 2019 sbin -\u0026gt; usr/sbin drwxr-xr-x 2 root root 4096 May 11 2019 srv dr-xr-xr-x 13 root root 0 Sep 8 04:03 sys drwxrwxrwt 7 root root 4096 Aug 9 21:40 tmp drwxr-xr-x 12 root root 4096 Aug 9 21:40 usr drwxr-xr-x 20 root root 4096 Aug 9 21:40 var 发布镜像 到DockerHub\n在dockerhub官网注册一个账号\ndockerhub官网：https://hub.docker.com/\n登录dockerhub账号\n[root@shishiyi mydockerfile]# docker login --help Usage:\tdocker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username [root@shishiyi mydockerfile]# docker login -u shishiyi Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 登录完毕后就可以提交自己的镜像了\n# 推送镜像的规范是： docker push 注册用户名/镜像名:tag # 推送镜像尽量带上版本号 [root@shishiyi mydockerfile]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos-entrypoint-test 0.1 68dbcdfd80a6 3 hours ago 215MB centos-cmd-test 0.1 adc267054d89 3 hours ago 215MB mycentos 0.1 09aaf2b838b6 4 hours ago 287MB centos latest 0d120b6ccaa8 4 weeks ago 215MB [root@shishiyi mydockerfile]# docker push shishiyi/mycentos:0.1 The push refers to repository [docker.io/shishiyi/mycentos] An image does not exist locally with the tag: shishiyi/mycentos #发现直接这样推送是不行的， 看错误An image does not exist locally with the tag: shishiyi/mycentos, #本地没有tag是shishiyi/mycentos的镜像. #解决办法，增加一个tag [root@shishiyi mydockerfile]# docker tag mycentos:0.1 shishiyi/mycentos:0.1 [root@shishiyi mydockerfile]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos-entrypoint-test 0.1 68dbcdfd80a6 3 hours ago 215MB centos-cmd-test 0.1 adc267054d89 4 hours ago 215MB shishiyi/mycentos 0.1 09aaf2b838b6 4 hours ago 287MB mycentos 0.1 09aaf2b838b6 4 hours ago 287MB centos latest 0d120b6ccaa8 4 weeks ago 215MB 然后再推送即可，记得带上版本号！\nDocker网络（容器互联) \u0026ndash;link(已过时) 容器之间是否可以通过名字ping通\n启动两个容器后，发现直接通过名字并不能ping通\n#可以使用 --link命令来解决 [root@shishiyi home]# docker run -d -P --name tomcat03 --link tomcat02 tomcat d5e88ace3eb8793c00e3441440347c2cbe52784e8771b6882edb47671631eb5f [root@shishiyi home]# docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.092 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.067 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.068 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.072 ms #但是不能反向ping通 [root@shishiyi home]# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known 其实这个tomcat03之所以能ping通tomcat02，本质是因为在tomcat03本地配置hosts文件\n#查看tomcat03的hosts文件 [root@shishiyi home]# docker exec -it tomcat03 cat /etc/hosts 127.0.0.1\tlocalhost ::1\tlocalhost ip6-localhost ip6-loopback fe00::0\tip6-localnet ff00::0\tip6-mcastprefix ff02::1\tip6-allnodes ff02::2\tip6-allrouters 172.17.0.3\ttomcat02 639797bb5b9b 172.17.0.4\td5e88ace3eb8 \u0026ndash;link命令就是在hosts文件中添加了一行 172.17.0.3\ttomcat02 639797bb5b9b\n自定义网络 [root@shishiyi /]# docker network ls NETWORK ID NAME DRIVER SCOPE b975ebb49b23 bridge bridge local fd952cfe82a0 host host local 50c346e922df none null local 网络模式\nbridge：桥接docker (默认的，自己创建也是使用bridge 模式) host ：和宿主机共用网络 none ：不配置网络 docker默认使用bridge 模式即docker0，但是docker0 不支持容器之间 通过名字直接访问，所以我们可以选择另一种方式即自定义网络\n#创建自己的网络 #\t--driver bridge 选择网络模式(不写默认为bridge) #\t--subnet 192.168.0.0/16 子网的路段 192.168.0.0/16表示从192.168.0.2到192.168.255.255 #\t--gateway 192.168.0.1\t网关地址即路由 [root@shishiyi /]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynetwork 8ecbbe2766eca4f95f19cc37f731bccaa305b440834abdce4006fe6ef3e5fecb [root@shishiyi /]# docker network ls NETWORK ID NAME DRIVER SCOPE b975ebb49b23 bridge bridge local fd952cfe82a0 host host local 8ecbbe2766ec mynetwork bridge local 50c346e922df none null local 自己定义的网络就配置好了！\n#\t创建容器时指定自己写的网关 [root@shishiyi /]# docker run -d -P --name tomcat-net-01 --net mynetwork tomcat b39086a191ca5da74eb88fce3bd27ccb5039ea36569ffc4a766b18075ea83cba [root@shishiyi /]# docker run -d -P --name tomcat-net-02 --net mynetwork tomcat 2c48396a0e18213eb913701d98d494546fa4ca7ce1ce316f04b4e7ac45d2aae7 #\t再次查看自己配置的网关 [root@shishiyi /]# docker network inspect mynetwork [ { \u0026#34;Name\u0026#34;: \u0026#34;mynetwork\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;8ecbbe2766eca4f95f19cc37f731bccaa305b440834abdce4006fe6ef3e5fecb\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2020-09-08T16:56:59.25870749+08:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: {}, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;192.168.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;192.168.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;2c48396a0e18213eb913701d98d494546fa4ca7ce1ce316f04b4e7ac45d2aae7\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;tomcat-net-02\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;7dcfa2ec9c4dc735aed6625791989ea78e8598d0a27d4540d5ef4ef9e0bfe84c\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:c0:a8:00:03\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;192.168.0.3/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;b39086a191ca5da74eb88fce3bd27ccb5039ea36569ffc4a766b18075ea83cba\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;tomcat-net-01\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;b988b92f99d56c415e7550c94179cd095ddd75ccb8bd7fb11454d213be6bbcab\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:c0:a8:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;192.168.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: {}, \u0026#34;Labels\u0026#34;: {} } ] #\t再次通过ip去ping连接 [root@shishiyi /]# docker exec -it tomcat-net-01 ping 192.168.0.3 PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data. 64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.073 ms 64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.062 ms 64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.076 ms #\t使用了自己写的网关，我们发现可以直接通过名字ping通 [root@shishiyi /]# docker exec -it tomcat-net-01 ping tomcat-net-02 PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data. 64 bytes from tomcat-net-02.mynetwork (192.168.0.3): icmp_seq=1 ttl=64 time=0.060 ms 64 bytes from tomcat-net-02.mynetwork (192.168.0.3): icmp_seq=2 ttl=64 time=0.065 ms ^C --- tomcat-net-02 ping statistics --- 结论：我们自定义的网络docker已经帮我们维护好了对应的关系，所以推荐使用自定义网络的方式\n好处：\n不同的集群使用不同的网络，保证了集群的安全和健康\n网络连通 怎么办到不同的网关下的容器之间相互连通\n#\t测试打通docker0网络下的tomcat01 #\t连通之后就是将tomcat01放到了mynetwork网络下 # 具体命令为：docker network connect mynetwork tomcat01 #\t相当于一个容器有了两个ip地址 #\tinspect命令查看自定义网络配置，发现确定添加了其它网络下的容器进来 ","permalink":"http://shaoyi.cc/posts/blog/docker/docker/","summary":"Docker安装步骤 安装Docker 安装 帮助文档： # yum安装gcc相关环境（需要确保 虚拟机可以上外网 ） yum -y install gcc yum -y install gcc-c++ #1、卸载旧的Doc","title":"Docker 容器"},{"content":"Docker 安装RabbitMQ 这里注意获取镜像的时候要获取management版本的，不要获取last版本的，management版本的才带有管理界面。\n查询镜像\n#搜索RabbitMQ镜像 [root@shishiyi /]# docker search rabbitmq:management 得到下列结果\n下载镜像\n#下载RabbitMQ镜像 [root@shishiyi /]# docker pull rabbitmq:management 出现如下结果\n运行镜像\n#运行RabbitMQ镜像 [root@shishiyi /]# docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq:management 访问管理界面\n地址为 服务器ip:15672 用户名和密码都是guest\nJava方式实现RabbitMQ 1、helloword 生产者\nimport com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.util.concurrent.TimeoutException; public class Provider { public static void main(String[] args) throws IOException, TimeoutException { //创建mq的连接工厂 ConnectionFactory connectionFactory = new ConnectionFactory(); //设置连接的服务器IP connectionFactory.setHost(\u0026#34;服务器ip\u0026#34;); //设置端口号 connectionFactory.setPort(5672); //设置连接的虚拟主机（类似数据库中的库） connectionFactory.setVirtualHost(\u0026#34;/ems\u0026#34;); //设置用户名 connectionFactory.setUsername(\u0026#34;ems\u0026#34;); //设置密码 connectionFactory.setPassword(\u0026#34;123\u0026#34;); //获取连接 Connection connection = connectionFactory.newConnection(); //获取连接的通道 Channel channel = connection.createChannel(); //通道绑定消息队列 //参数1：队列名称，如果不存在则自动创建 //参数2：是否持久队列 //参数3：是否独占队列 //参数4： 是否消费完毕删除队列 //参数5：额外附加参数 channel.queueDeclare(\u0026#34;hello\u0026#34;,false,false,false,null); //发布消息 //参数1：交换机；参数2：队列名称；参数3：传递消息的额外设置；参数4：消息内容 channel.basicPublish(\u0026#34;\u0026#34;,\u0026#34;hello\u0026#34;,null,\u0026#34;hello rabbitmq\u0026#34;.getBytes()); //关闭资源 channel.close(); connection.close(); } } 消费者\nimport com.rabbitmq.client.*; import java.io.IOException; import java.util.concurrent.TimeoutException; public class Consumer { public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\u0026#34;服务器ip\u0026#34;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\u0026#34;/ems\u0026#34;); connectionFactory.setUsername(\u0026#34;ems\u0026#34;); connectionFactory.setPassword(\u0026#34;123\u0026#34;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(\u0026#34;hello\u0026#34;,false,false,false,null); //参数1：队列名称，参数2：开始消息的自动确认机制，参数3：消费时的回调接口 channel.basicConsume(\u0026#34;hello\u0026#34;,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\u0026#34;消费的内容：\u0026#34;+new String(body)); } }); } } 提取公共部分，创建工具类 RabbitMQUtils\nimport com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.util.concurrent.TimeoutException; public class RabbitMQUtils { private static ConnectionFactory connectionFactory = null; static { connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\u0026#34;服务器ip\u0026#34;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\u0026#34;/ems\u0026#34;); connectionFactory.setUsername(\u0026#34;ems\u0026#34;); connectionFactory.setPassword(\u0026#34;123\u0026#34;); } //获取连接 public static Connection getConnection(){ try { Connection connection = connectionFactory.newConnection(); return connection; } catch (IOException e) { e.printStackTrace(); } catch (TimeoutException e) { e.printStackTrace(); } return null; } //关闭资源 public static void clone(Channel channel , Connection connection){ try { if (null !=channel) channel.close(); if (null != connection) connection.close(); } catch (IOException e) { e.printStackTrace(); } catch (TimeoutException e) { e.printStackTrace(); } } } 2、Work queues 生产者\npackage com.shishiyi.work; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.shishiyi.utils.RabbitMQUtils; import java.io.IOException; public class Provider { public static void main(String[] args) throws IOException { Connection connection = RabbitMQUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(\u0026#34;work\u0026#34;,false,false,false,null); for (int i = 0; i \u0026lt; 10 ; i++) { channel.basicPublish(\u0026#34;\u0026#34;,\u0026#34;work\u0026#34;,null,\u0026#34;work queue\u0026#34;.getBytes()); } RabbitMQUtils.clone(channel,connection); } } 消费者1\nConnection connection = RabbitMQUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(\u0026#34;work\u0026#34;,false,false,false,null); channel.basicConsume(\u0026#34;work\u0026#34;,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\u0026#34;work 消费者1：\u0026#34;+new String(body)); } }); 消费者2\nConnection connection = RabbitMQUtils.getConnection(); Channel channel = connection.createChannel(); channel.basicConsume(\u0026#34;work\u0026#34;,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\u0026#34;work 消费者2：\u0026#34;+new String(body)); } }); 3、fanout 生产者\n//将通道声明为交换机 //参数1：交换机名称；参数2：交换机类型 fanout为广播类型 channel.exchangeDeclare(\u0026#34;logs\u0026#34;,\u0026#34;fanout\u0026#34;); //发送消息 channel.basicPublish(\u0026#34;logs\u0026#34;,\u0026#34;\u0026#34;,null,\u0026#34;fanout type message\u0026#34;.getBytes()); RabbitMQUtils.clone(channel,connection); 消费者一\n//通道声明为交换机 channel.exchangeDeclare(\u0026#34;logs\u0026#34;,\u0026#34;fanout\u0026#34;); //临时的队列 String queue = channel.queueDeclare().getQueue(); //通道绑定临时队列和交换机 channel.queueBind(queue,\u0026#34;logs\u0026#34;,\u0026#34;\u0026#34;); channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\u0026#34;fanout1====\u0026gt;\u0026#34;+new String(body)); } }); 消费者二\n//通道声明为交换机 channel.exchangeDeclare(\u0026#34;logs\u0026#34;,\u0026#34;fanout\u0026#34;); //临时队列 String queue = channel.queueDeclare().getQueue(); //通道绑定临时队列和交换机 channel.queueBind(queue,\u0026#34;logs\u0026#34;,\u0026#34;\u0026#34;); channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\u0026#34;fanout2====\u0026gt;\u0026#34;+new String(body)); } }); 4、direct 生产者\nchannel.exchangeDeclare(\u0026#34;direct_logs\u0026#34;,\u0026#34;direct\u0026#34;); String routingKey = \u0026#34;info\u0026#34;; channel.basicPublish(\u0026#34;direct_logs\u0026#34;,routingKey,null,(\u0026#34;direct发送了一条routingKey为\u0026#34;+routingKey+\u0026#34;的消息\u0026#34;).getBytes()); 消费者一\nchannel.exchangeDeclare(\u0026#34;direct_logs\u0026#34;,\u0026#34;direct\u0026#34;); String queue = channel.queueDeclare().getQueue(); channel.queueBind(queue,\u0026#34;direct_logs\u0026#34;,\u0026#34;error\u0026#34;); channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\u0026#34;direct消费者1: \u0026#34;+new String(body)); } }); 消费者二\nchannel.exchangeDeclare(\u0026#34;direct_logs\u0026#34;,\u0026#34;direct\u0026#34;); String queue = channel.queueDeclare().getQueue(); channel.queueBind(queue,\u0026#34;direct_logs\u0026#34;,\u0026#34;info\u0026#34;); channel.queueBind(queue,\u0026#34;direct_logs\u0026#34;,\u0026#34;error\u0026#34;); channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\u0026#34;direct消费者2：\u0026#34;+new String(body)); } }); 5、topic *符号可以代替一个单词。 ＃符号可以替代零个或多个单词。 生产者\nchannel.exchangeDeclare(\u0026#34;topic_logs\u0026#34;,\u0026#34;topic\u0026#34;); String routingKey = \u0026#34;user.find.save\u0026#34;; channel.basicPublish(\u0026#34;topic_logs\u0026#34;,routingKey,null,(\u0026#34;发送了一条routingKey为\u0026#34;+routingKey+\u0026#34;的消息\u0026#34;).getBytes()); 消费者一\nchannel.exchangeDeclare(\u0026#34;topic_logs\u0026#34;,\u0026#34;topic\u0026#34;); String queue = channel.queueDeclare().getQueue(); String routingKey = \u0026#34;user.*\u0026#34;; channel.queueBind(queue,\u0026#34;topic_logs\u0026#34;,routingKey); channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\u0026#34;topic消费者1：\u0026#34;+new String(body)); } }); 消费者二\nchannel.exchangeDeclare(\u0026#34;topic_logs\u0026#34;,\u0026#34;topic\u0026#34;); String queue = channel.queueDeclare().getQueue(); String routingKey = \u0026#34;user.#\u0026#34;; channel.queueBind(queue,\u0026#34;topic_logs\u0026#34;,routingKey); channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\u0026#34;topic消费者2：\u0026#34;+new String(body)); } }); Springboot实现方式 消费者方绑定队列和交换机的方式 环境 \u0026lt;!--创建Springboot工程，导入Maven依赖-——\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 编写application.yml文件\nspring: application: name: rabbitmq_springboot rabbitmq: host: 服务器ip port: 5672 username: ems #用户名 password: 123 #密码 virtual-host: /ems\t#虚拟机名称 1、helloword 生产者\n@Autowired private RabbitTemplate rabbitTemplate; @Test public void test() { rabbitTemplate.convertAndSend(\u0026#34;hello\u0026#34;,\u0026#34;hello world\u0026#34;); } 消费者\nimport org.springframework.amqp.rabbit.annotation.Queue; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queuesToDeclare = @Queue(\u0026#34;hello\u0026#34;)) public class Consumer_hello { @RabbitHandler public void receive(String message){ System.out.println(\u0026#34;消费的内容：\u0026#34;+message); } } 2、Work queues 生产者\n@Autowired private RabbitTemplate rabbitTemplate; @Test public void work(){ for (int i = 0; i \u0026lt; 10; i++) { rabbitTemplate.convertAndSend(\u0026#34;work\u0026#34;,\u0026#34; work \u0026#34;+i); } } 消费者\nimport org.springframework.amqp.rabbit.annotation.Queue; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component public class Consumer_Work { @RabbitListener(queuesToDeclare = @Queue(\u0026#34;work\u0026#34;)) public void receive1(String messages){ System.out.println(\u0026#34;work消费者1:\u0026#34;+messages); } @RabbitListener(queuesToDeclare = @Queue(\u0026#34;work\u0026#34;)) public void receive2(String messages){ System.out.println(\u0026#34;work消费者2:\u0026#34;+messages); } } 3、fanout 生产者\n@Autowired private RabbitTemplate rabbitTemplate; @Test public void fanout(){ rabbitTemplate.convertAndSend(\u0026#34;fanout_logs\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;fanout发的消息\u0026#34;); } 消费者\nimport org.springframework.amqp.rabbit.annotation.Exchange; import org.springframework.amqp.rabbit.annotation.Queue; import org.springframework.amqp.rabbit.annotation.QueueBinding; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component public class Consumer_Fanout { @RabbitListener(bindings = { @QueueBinding( value = @Queue, //创建临时队列 exchange = @Exchange(value = \u0026#34;logs_fanout\u0026#34;,type = \u0026#34;fanout\u0026#34;) //自定义交换机名称和类型，并绑定交换机 )}) public void receive1(String messages){ System.out.println(\u0026#34;fanout消费者1:\u0026#34;+messages); } @RabbitListener(bindings = { @QueueBinding( value = @Queue, //创建临时队列 exchange = @Exchange(value = \u0026#34;logs_fanout\u0026#34;,type = \u0026#34;fanout\u0026#34;) //自定义交换机名称和类型，并绑定交换机 )}) public void receive2(String messages){ System.out.println(\u0026#34;fanout消费者2:\u0026#34;+messages); } } 4、direct 生产者\n@Autowired private RabbitTemplate rabbitTemplate; @Test public void route(){ String routingKey = \u0026#34;info\u0026#34;; rabbitTemplate.convertAndSend(\u0026#34;route_logs\u0026#34;,routingKey,\u0026#34;info的消息\u0026#34;); } 消费者\nimport org.springframework.amqp.rabbit.annotation.Exchange; import org.springframework.amqp.rabbit.annotation.Queue; import org.springframework.amqp.rabbit.annotation.QueueBinding; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component public class Consumer_Route { @RabbitListener( bindings = @QueueBinding( value = @Queue,\t//创建临时队列 exchange = @Exchange(value = \u0026#34;route_logs\u0026#34;,type = \u0026#34;direct\u0026#34;),\t//自定义交换机名称和类型，并绑定交换机 key = {\u0026#34;error\u0026#34;}\t//设置路由 ) ) public void receive1(String messages){ System.out.println(\u0026#34;Route消费者1: \u0026#34;+messages); } @RabbitListener( bindings = @QueueBinding( value = @Queue,\t//创建临时队列 exchange = @Exchange(value = \u0026#34;route_logs\u0026#34;,type = \u0026#34;direct\u0026#34;),\t//自定义交换机名称和类型，并绑定交换机 key = {\u0026#34;info\u0026#34;,\u0026#34;error\u0026#34;}\t//设置路由 ) ) public void receive2(String messages){ System.out.println(\u0026#34;Route消费者2: \u0026#34;+messages); } } 5、topic 生产者\n@Autowired private RabbitTemplate rabbitTemplate; @Test public void topic(){ String routingKey = \u0026#34;user.find\u0026#34;; rabbitTemplate.convertAndSend(\u0026#34;topic_logs\u0026#34;,routingKey,\u0026#34;topic发送的消息\u0026#34;); } 消费者\nimport org.springframework.amqp.rabbit.annotation.Exchange; import org.springframework.amqp.rabbit.annotation.Queue; import org.springframework.amqp.rabbit.annotation.QueueBinding; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component public class Consumer_Topic { @RabbitListener( bindings = { @QueueBinding( value = @Queue,\t//创建临时队列 exchange = @Exchange(value = \u0026#34;topic_logs\u0026#34;,type = \u0026#34;topic\u0026#34;),\t//自定义交换机名称和类型，并绑定交换机 key = {\u0026#34;user.#\u0026#34;} ) } ) public void receive1(String messages){ System.out.println(\u0026#34;topic消费者1: \u0026#34;+messages); } @RabbitListener(bindings = @QueueBinding( value = @Queue,\t//创建临时队列 exchange = @Exchange(value = \u0026#34;topic_logs\u0026#34;,type = \u0026#34;topic\u0026#34;),\t//自定义交换机名称和类型，并绑定交换机 key = {\u0026#34;user.*\u0026#34;} )) public void receive2(String messages){ System.out.println(\u0026#34;topic消费者2: \u0026#34;+messages); } } 生产者方绑定队列和交换机的方式 1、fanout 生产者方 在pom.xml文件导入Maven依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置application.yml文件\nserver: port: 8001 spring: application: name: rabbitmq_springboot_fanout_provider rabbitmq: host: 服务器ip port: 5672 #rabbitmq端口号 username: shishiyi\t#用户名 password: 123\t#密码 virtual-host: /shishiyi\t#虚拟机名称 编写配置类\nimport org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class ConfigRabbitmqFanout { //创建三个队列分别为fanoutQueue1，fanoutQueue2，fanoutQueue3 @Bean public Queue fanoutQueue1(){ return QueueBuilder.durable(\u0026#34;fanoutQueue1\u0026#34;).build(); } @Bean public Queue fanoutQueue2(){ return QueueBuilder.durable(\u0026#34;fanoutQueue2\u0026#34;).build(); } @Bean public Queue fanoutQueue3(){ return QueueBuilder.durable(\u0026#34;fanoutQueue3\u0026#34;).build(); } //创建fanout类型的交换机 @Bean public FanoutExchange fanoutExchange(){ return ExchangeBuilder.fanoutExchange(\u0026#34;fanoutExchange\u0026#34;).build(); } //把三个队列分别和交换机进行绑定 @Bean public Binding bindingExchange1(){ return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange()); } @Bean public Binding bindingExchange2(){ return BindingBuilder.bind(fanoutQueue2()).to(fanoutExchange()); } @Bean public Binding bindingExchange3(){ return BindingBuilder.bind(fanoutQueue3()).to(fanoutExchange()); } } 编写生产者的接口，发送消息\nimport org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class FanoutController { @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(\u0026#34;/sendFanout\u0026#34;) public void sendMessages(){ rabbitTemplate.convertAndSend(\u0026#34;fanoutExchange\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;fanout类型发送的消息\u0026#34;); } } 启动项目，调用接口\n检查rabbitMq管理页，消息已经发送成功\n消费者方 在pom.xml文件导入Maven依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置application.yml文件\nserver: port: 7001 spring: application: name: rabbitmq_springboot_fanout_consumer rabbitmq: host: 服务器ip port: 5672 #rabbitmq端口号 username: shishiyi\t#用户名 password: 123\t#密码 virtual-host: /shishiyi\t#虚拟机名称 编写监听类\nimport org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component public class FanoutReceiver { //监听对应的队列名称 @RabbitListener(queues = \u0026#34;fanoutQueue1\u0026#34;) public void fanout1(Message message){ System.out.println(\u0026#34;fanoutQueue1 消费者接受的消息：\u0026#34;+message); } @RabbitListener(queues = \u0026#34;fanoutQueue2\u0026#34;) public void fanout2(Message message){ System.out.println(\u0026#34;fanoutQueue2 消费者接受的消息：\u0026#34;+message); } @RabbitListener(queues = \u0026#34;fanoutQueue3\u0026#34;) public void fanout3(Message message){ System.out.println(\u0026#34;fanoutQueue3 消费者接受的消息：\u0026#34;+message); } } 启动项目，查看控制台\n2、direct 生产者方 pom.xml文件\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; application.yml文件\nserver: port: 8002 spring: application: name: rabbitmq_springboot_direct_provider rabbitmq: host: 服务ip port: 5672 username: shishiyi password: 123 virtual-host: /shishiyi 编写配置类\nimport org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class ConfigRabbitmqDirect { @Bean public Queue directQueue1(){ return QueueBuilder.durable(\u0026#34;directQueue1\u0026#34;).build(); } @Bean public Queue directQueue2(){ return QueueBuilder.durable(\u0026#34;directQueue2\u0026#34;).build(); } @Bean public DirectExchange directExchange(){ return ExchangeBuilder.directExchange(\u0026#34;directExchange\u0026#34;).build(); } //绑定对应的队列，以及路由key @Bean public Binding bindingExchangeQueue1(){ return BindingBuilder.bind(directQueue1()).to(directExchange()).with(\u0026#34;info\u0026#34;); } @Bean public Binding bindingExchangeQueue2(){ return BindingBuilder.bind(directQueue2()).to(directExchange()).with(\u0026#34;error\u0026#34;); } } 编写生产者的接口，发送消息\nimport org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class DirectController { @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(\u0026#34;/sendDirect\u0026#34;) public void sendMessages(){\t//路由key值为info rabbitTemplate.convertAndSend(\u0026#34;directExchange\u0026#34;,\u0026#34;info\u0026#34;,\u0026#34;这是direct类型,路由为info的消息\u0026#34;); } } 启动项目，调用接口\n查看rabbitmq控制台，由于发送消息方法是往路由key值为info队列发送，所以只有路由key为info的directQueue1队列可以接收到，而路由key值为error的directQueue2队列接受不到消息\n消费者方 pom.xml文件\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; application.yml文件\nserver: port: 7002 spring: application: name: rabbitmq_springboot_direct_consumer rabbitmq: host: 服务器ip port: 5672 #rabbitmq端口号 username: shishiyi\t#用户名 password: 123\t#密码 virtual-host: /shishiyi\t#虚拟机名称 编写监听类\nimport org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component public class DirectReceiver { @RabbitListener(queues = \u0026#34;directQueue1\u0026#34;) public void directQueue1(Message message){ System.out.println(\u0026#34;directQueue1 消费者接收到的消息：\u0026#34;+message); } @RabbitListener(queues = \u0026#34;directQueue2\u0026#34;) public void directQueue2(Message message){ System.out.println(\u0026#34;directQueue2 消费者接收到的消息：\u0026#34;+message); } } 启动项目，查看控制台，由于只有directQueue1里有消息，所以消费者只能看到这个队列消息\n3、topic 生产者 编写pom.xml文件，导入Maven依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置文件application.yml\nserver: port: 8003 spring: application: name: rabbitmq_springboot_topic_provider rabbitmq: host: 服务器ip port: 5672 username: shishiyi\t#用户名 password: 123\t#密码 virtual-host: /shishiyi\t#虚拟机名称 编写配置类\nimport org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class ConfigRabbitmqTopic { @Bean public Queue topicQueue1(){ return QueueBuilder.durable(\u0026#34;topicQueue1\u0026#34;).build(); } @Bean public Queue topicQueue2(){ return QueueBuilder.durable(\u0026#34;topicQueue2\u0026#34;).build(); } @Bean public Queue topicQueue3(){ return QueueBuilder.durable(\u0026#34;topicQueue3\u0026#34;).build(); } @Bean public TopicExchange topicExchange(){ return ExchangeBuilder.topicExchange(\u0026#34;topicExchange\u0026#34;).build(); } //绑定队列和交换机，以及绑定了不同的路由key值 @Bean public Binding bindingExchangeQueue1(){ return BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(\u0026#34;user.#\u0026#34;); } @Bean public Binding bindingExchangeQueue2(){ return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(\u0026#34;user.save\u0026#34;); } @Bean public Binding bindingExchangeQueue3(){ return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(\u0026#34;user\u0026#34;); } } 编写接口\nimport org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class TopicController { @Autowired public RabbitTemplate rabbitTemplate; @GetMapping(\u0026#34;/sendTopic\u0026#34;) public void sendMessage(){ //路由key为user.save rabbitTemplate.convertAndSend(\u0026#34;topicExchange\u0026#34;,\u0026#34;user.save\u0026#34;,\u0026#34;这是topic类型，路由为user.save的消息\u0026#34;); } } 启动项目，调用接口\n查看rabbitmq控制台，由于发送消息的方法 路由key值为user.save，所以只有路由key为user.#的topicQueue1的队列和路由key值为user.save的topicQueue2队列可以收到消息，而路由key值为user的topicQueue3队列则收不到消息\n消费者方 pom.xml文件\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; application.yml文件\nserver: port: 7003 spring: application: name: rabbitmq_springboot_topic_consumer rabbitmq: host: 服务器ip port: 5672 username: shishiyi password: 123 virtual-host: /shishiyi 编写监听类，获取消息\nimport org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component public class TopicReceiver { @RabbitListener(queues = \u0026#34;topicQueue1\u0026#34;) public void topicQueue1(Message message){ System.out.println(\u0026#34;topicQueue1 消费者接收到的消息：\u0026#34;+message); } @RabbitListener(queues = \u0026#34;topicQueue2\u0026#34;) public void topicQueue2(Message message){ System.out.println(\u0026#34;topicQueue2 消费者接收到的消息：\u0026#34;+message); } @RabbitListener(queues = \u0026#34;topicQueue3\u0026#34;) public void topicQueue3(Message message){ System.out.println(\u0026#34;topicQueue3 消费者接收到的消息：\u0026#34;+message); } } 启动项目，在控制台查看打印信息，由于只有队列topicQueue1，topicQueue2里有消息，所以消费者只能看到这两个队列消息\nRabbitMQ的高级特性 生产者方消息确认机制 在使用RabbitMQ的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式。\nconfirm 确认模式 return 退回模式 RabbitMQ大体流程路径：\n消息从消费者(Producer) 到 交换机(exchange) 则会调用一个回调方法setConfirmCallback()\n​\t方法参数： correlationData 相关信息、ack 是否发送成功、cause 失败原因\n消息从交换机(exchange)到 队列(queue) 则会调用一个回调方法setReturnCallback()\n​\t方法参数： message消息内容、 replyCode回应码、replyText回应消息、exchange交换机、routingKey路由key值\n编写配置文件application.yml\nserver: port: 8004 spring: application: name: rabbitmq_springboot_provider rabbitmq: host: 服务器ip port: 5672 username: shishiyi password: 123 virtual-host: /shishiyi #消息确认配置项 #确认消息已发送到交换机(Exchange) publisher-confirm-type: correlated #确认消息已发送到队列(Queue) publisher-returns: true 编写配置类\nimport org.springframework.amqp.core.*; import org.springframework.amqp.rabbit.connection.ConnectionFactory; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitmqConfig { @Bean public RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory){ RabbitTemplate rabbitTemplate = new RabbitTemplate(); rabbitTemplate.setConnectionFactory(connectionFactory); /** * 从消费者(Producer) 到 交换机(exchange) 则会被调用 */ rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -\u0026gt; { System.out.println(\u0026#34;ConfirmCallback 相关数据: \u0026#34;+correlationData); System.out.println(\u0026#34;ConfirmCallback 确认情况: \u0026#34;+ack); System.out.println(\u0026#34;ConfirmCallback 原因: \u0026#34;+cause); }); //设置开启Mandatory,才能触发回调函数,无论消息推送结果怎么样都强制调用回调函数 rabbitTemplate.setMandatory(true); /** * 从交换机(exchange)到 队列(queue) 则会被调用 */ rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -\u0026gt; { System.out.println(\u0026#34;ReturnCallback 消息内容: \u0026#34;+message); System.out.println(\u0026#34;ReturnCallback 回应码: \u0026#34;+replyCode); System.out.println(\u0026#34;ReturnCallback 回应消息: \u0026#34;+replyText); System.out.println(\u0026#34;ReturnCallback 交换机: \u0026#34;+exchange); System.out.println(\u0026#34;ReturnCallback 路由key值: \u0026#34;+routingKey); }); return rabbitTemplate; } @Bean public Queue queue(){ return QueueBuilder.durable(\u0026#34;topic_queue\u0026#34;).build(); } @Bean public TopicExchange topicExchange(){ return ExchangeBuilder.topicExchange(\u0026#34;topic_exchange\u0026#34;).build(); } @Bean public Binding binding(){ return BindingBuilder.bind(queue()).to(topicExchange()).with(\u0026#34;yes.#\u0026#34;); } } 编写接口\nimport org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class TopicController { @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(\u0026#34;/send\u0026#34;) public void sendMessage(){ rabbitTemplate.convertAndSend(\u0026#34;topic_exchange\u0026#34;,\u0026#34;yes\u0026#34;,\u0026#34;发布了一条消息\u0026#34;); } } 启动测试，查看控制台信息\n根据RabbitMQ大体流程路径，从生产者角度，做如下测试：\n1、如果发送的交换机没有进行配置，即不存在\n//交换机为exchange1111，没有进行配置 @GetMapping(\u0026#34;/send\u0026#34;) public void sendMessage(){ rabbitTemplate.convertAndSend(\u0026#34;exchange1111\u0026#34;,\u0026#34;yes\u0026#34;,\u0026#34;发布了一条消息\u0026#34;); } 启动测试，调用接口，查看控制台\nConfirmCallback 相关数据: null ConfirmCallback 确认情况: false ConfirmCallback 原因: channel error; protocol method: #method\u0026lt;channel.close\u0026gt;(reply-code=404, reply-text=NOT_FOUND - no exchange \u0026#39;exchange1111\u0026#39; in vhost \u0026#39;/shishiyi\u0026#39;, class-id=60, method-id=40) 2、如果交换机配置了，但是没有绑定队列\n//配置交换机，但不绑定队列 @Bean public TopicExchange exchange2(){ return ExchangeBuilder.topicExchange(\u0026#34;topic_exchange_test\u0026#34;).build(); } //给没有绑定的交换机发送消息 @GetMapping(\u0026#34;/send\u0026#34;) public void sendMessage(){ rabbitTemplate.convertAndSend(\u0026#34;topic_exchange_test\u0026#34;,\u0026#34;yes\u0026#34;,\u0026#34;发布了一条消息\u0026#34;); } 启动测试，调用接口，查看控制台\nReturnCallback 消息内容: (Body:\u0026#39;发布了一条消息\u0026#39; MessageProperties [headers={}, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, deliveryTag=0]) ReturnCallback 回应码: 312 ReturnCallback 回应消息: NO_ROUTE ReturnCallback 交换机: topic_exchange_test ReturnCallback 路由key值: yes ConfirmCallback 相关数据: null ConfirmCallback 确认情况: true ConfirmCallback 原因: null 消费者方消息确认机制 这里是把消息的自动确认机制，改为手动确认消息，即把 AcknowledgeMode.NONE 改为 AcknowledgeMode.MANUAL\n配置文件application.yml\nserver: port: 7004 spring: application: name: rabbitmq_springboot_consumer rabbitmq: host: 服务器ip port: 5672 username: shishiyi password: 123 virtual-host: /shishiyi 编写开启手动确认，以及自定义监听类\nimport com.shishiyi.listener.AckListener; import org.springframework.amqp.core.AcknowledgeMode; import org.springframework.amqp.rabbit.connection.ConnectionFactory; import org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MessageListenerConfig { @Autowired private AckListener ackListener; @Autowired private ConnectionFactory connectionFactory; @Bean public SimpleMessageListenerContainer simpleMessageListenerContainer(){ SimpleMessageListenerContainer simpleMessageListenerContainer = new SimpleMessageListenerContainer(connectionFactory); //消费者改为手动确认，默认为自动确认 simpleMessageListenerContainer.setAcknowledgeMode(AcknowledgeMode.MANUAL); //设置队列，参数可以设置多个队列名称 simpleMessageListenerContainer.setQueueNames(\u0026#34;topic_queue\u0026#34;); //设置自定义的监听类 simpleMessageListenerContainer.setMessageListener(ackListener); return simpleMessageListenerContainer; } } import com.rabbitmq.client.Channel; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener; import org.springframework.stereotype.Component; import java.io.IOException; @Component public class AckListener implements ChannelAwareMessageListener { @Override public void onMessage(Message message, Channel channel) throws Exception { long deliveryTag = message.getMessageProperties().getDeliveryTag(); try { //判断队列，可以针对不同队列，来执行不同的业务内容 if (\u0026#34;topic_queue\u0026#34;.equals(message.getMessageProperties().getConsumerQueue())){ //转换消息 System.out.println(new String(message.getBody())); //处理业务 System.out.println(\u0026#34;处理业务.........\u0026#34;); } //手动确认，签收消息 channel.basicAck(deliveryTag,true); } catch (IOException e) { /** * 针对多个消息 * 第二个参数是否应用于多消息 * 第三个参数requeue：是否重回队列，如果是true,则重新回到队列，然后重新发给消费者，否者则丢弃或者进入死信队列 */ channel.basicNack(deliveryTag,true,false); //针对单个消息，第二个参数requeue：是否重回队列 //channel.basicReject(deliveryTag,true); } } } 如果执行业务出错，则可以拒绝消息，对此方法有channel.basicReject(deliveryTag, true) 和 channel.basicNack(deliveryTag, false, true) 两种方式处理\nchannel.basicReject(deliveryTag, true)： 拒绝消费当前消息，如果第二参数传入true，就是将数据重新丢回队列里，那么下次还会消费这消息。设置false，\n就是告诉服务器，我已经知道这条消息数据了，因为一些原因拒绝它，而且服务器也把这个消息丢掉就行。 下次不想再消费这条消息了。使用拒绝后重新入列这\n个确认模式要谨慎，因为一般都是出现异常的时候，catch异常再拒绝入列，选择是否重入列。但是如果使用不当会导致一些每次都被你重入列的消息一直消费-入\n列-消费-入列这样循环，会导致消息积压。\nchannel.basicNack(deliveryTag, false, true)： 第一个参数依然是当前消息到的数据的唯一id；\n第二个参数是指是否针对多条消息；如果是true，也就是说一次性针对当前通道的消息的tagID小于当前这条消息的，都拒绝确认。\n第三个参数是指是否重新入列，也就是指不确认的消息是否重新丢回到队列里面去。\n同样使用不确认后重新入列这个确认模式要谨慎，因为这里也可能因为考虑不周出现消息一直被重新丢回去的情况，导致积压。\n消费端限流 为防止大量消息全部给到消费端系统，可以对消费端做一个限流操作\n开启方式的前提一定是消费端改为手动确认信息，否则就不成功\nSimpleMessageListenerContainer simpleMessageListenerContainer = new SimpleMessageListenerContainer(connectionFactory); //消费者改为手动确认，默认为自动确认 simpleMessageListenerContainer.setAcknowledgeMode(AcknowledgeMode.MANUAL); //对消费端进行一个限流设置，一次允许多少消息进入 simpleMessageListenerContainer.setPrefetchCount(1); TTL：消息过期时间 1、队列内消息统一过期 @Bean public Queue queue(){\t//只需要在配置队列时，设置一下ttl(int ttl)方法，参数为多少毫秒后消息过期 return QueueBuilder.durable(\u0026#34;topic_queue\u0026#34;).ttl(5000).build(); } 2、消息单独过期 单独为某条消息设置过期属性，可以通过发布消息的convertAndSend()重载方法中，MessagePostProcessor消息发布处理器来设置过期属性\n通过源码可以发现，MessagePostProcessor是一个函数式接口，而接口的方法有一个Message类型的参数，以此便可以设置消息属性了\n//发布消息时，单独设置一下消息过期时间 public void sendMessage(){ rabbitTemplate.convertAndSend(\u0026#34;topic_exchange\u0026#34;,\u0026#34;yes\u0026#34;,\u0026#34;发布了一条消息\u0026#34;,message -\u0026gt; { message.getMessageProperties().setExpiration(\u0026#34;5000\u0026#34;); return message; }); } 不过，需要注意的是，当队列中有多条消息，有过期时间的消息不会在达到时间后从队列中自动消失，而是只有消息在队列顶端时，才会判断其否过期了\n而如果同时设置队列过期时间和消息过期时间，则以时间短的为准\n死信队列 Rabbitmq的死信队列，其实指的死信交换机(DLX)，但虽然名称是这么一个叫法，但是死信交换机也是一个正常的交换机，和一般的交换机是没有区别的\n而进入死信交换机的消息，大致有三种情况：\n1、消息TTL过期 生产方的配置类\nimport org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitmqConfig { //声明正常队列 @Bean public Queue queue(){ return QueueBuilder.durable(\u0026#34;topic_queue\u0026#34;) //正常队列和死信交换机绑定 .deadLetterExchange(\u0026#34;topic_exchange_dlx\u0026#34;) //和死信交换机的路由key绑定，发给哪个死信队列 .deadLetterRoutingKey(\u0026#34;no.msg\u0026#34;) //设置队列过期时间，3秒后过期 .ttl(3000) .build(); } //声明正常交换机 @Bean public TopicExchange exchange(){ return ExchangeBuilder.topicExchange(\u0026#34;topic_exchange\u0026#34;).build(); } //正常的队列和交换机进行绑定 @Bean public Binding binding(){ return BindingBuilder.bind(queue()).to(exchange()).with(\u0026#34;yes.#\u0026#34;); } //声明死信队列 @Bean public Queue queue_dlx(){ return QueueBuilder.durable(\u0026#34;topic_queue_dlx\u0026#34;).build(); } //声明死信交换机 @Bean public TopicExchange exchange_dlx(){ return ExchangeBuilder.topicExchange(\u0026#34;topic_exchange_dlx\u0026#34;).build(); } //死信的队列和交换机进行绑定 @Bean public Binding binding_dlx(){ return BindingBuilder.bind(queue_dlx()).to(exchange_dlx()).with(\u0026#34;no.#\u0026#34;); } } 编写接口\nimport org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class TopicController { @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(\u0026#34;/send\u0026#34;) public void sendMessage(){ rabbitTemplate.convertAndSend(\u0026#34;topic_exchange\u0026#34;,\u0026#34;yes.msg\u0026#34;,\u0026#34;发布了一条消息\u0026#34;); } } 启动测试，调用接口发送消息，不消费消息，3秒后查看rabbitmq管理页面，消息已进入死信队列\n2、队列达到最大长度 生产方的配置类\nimport org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitmqConfig { //声明正常队列 @Bean public Queue queue(){ return QueueBuilder.durable(\u0026#34;topic_queue\u0026#34;) //正常队列和死信交换机绑定 .deadLetterExchange(\u0026#34;topic_exchange_dlx\u0026#34;) //和死信交换机的路由key绑定，发给哪个死信队列 .deadLetterRoutingKey(\u0026#34;no.msg\u0026#34;) //指定队列最大接受长度(最大接受消息数) .maxLength(5) .build(); } //声明正常交换机 @Bean public TopicExchange exchange(){ return ExchangeBuilder.topicExchange(\u0026#34;topic_exchange\u0026#34;).build(); } //正常的队列和交换机进行绑定 @Bean public Binding binding(){ return BindingBuilder.bind(queue()).to(exchange()).with(\u0026#34;yes.#\u0026#34;); } //声明死信队列 @Bean public Queue queue_dlx(){ return QueueBuilder.durable(\u0026#34;topic_queue_dlx\u0026#34;).build(); } //声明死信交换机 @Bean public TopicExchange exchange_dlx(){ return ExchangeBuilder.topicExchange(\u0026#34;topic_exchange_dlx\u0026#34;).build(); } //死信的队列和交换机进行绑定 @Bean public Binding binding_dlx(){ return BindingBuilder.bind(queue_dlx()).to(exchange_dlx()).with(\u0026#34;no.#\u0026#34;); } } 编写接口\nimport org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class TopicController { @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(\u0026#34;/send\u0026#34;) public void sendMessage(){ //发送10条信息 for (int i = 0; i \u0026lt; 10; i++) { rabbitTemplate.convertAndSend(\u0026#34;topic_exchange\u0026#34;,\u0026#34;yes.msg\u0026#34;,\u0026#34;发布了一条消息\u0026#34;); } } } 启动测试，调用接口发送消息，不消费消息，查看rabbitmq管理页面，由于设置队列最大长度为5，所以有5条消息进入死信队列\n3、消息被拒绝 编写生产方配置类\nimport org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitmqConfig { //声明正常队列 @Bean public Queue queue(){ return QueueBuilder.durable(\u0026#34;topic_queue\u0026#34;) //正常队列和死信交换机绑定 .deadLetterExchange(\u0026#34;topic_exchange_dlx\u0026#34;) //和死信交换机的路由key绑定，发给哪个死信队列 .deadLetterRoutingKey(\u0026#34;no.msg\u0026#34;) .build(); } //声明正常交换机 @Bean public TopicExchange exchange(){ return ExchangeBuilder.topicExchange(\u0026#34;topic_exchange\u0026#34;).build(); } //正常的队列和交换机进行绑定 @Bean public Binding binding(){ return BindingBuilder.bind(queue()).to(exchange()).with(\u0026#34;yes.#\u0026#34;); } //声明死信队列 @Bean public Queue queue_dlx(){ return QueueBuilder.durable(\u0026#34;topic_queue_dlx\u0026#34;).build(); } //声明死信交换机 @Bean public TopicExchange exchange_dlx(){ return ExchangeBuilder.topicExchange(\u0026#34;topic_exchange_dlx\u0026#34;).build(); } //死信的队列和交换机进行绑定 @Bean public Binding binding_dlx(){ return BindingBuilder.bind(queue_dlx()).to(exchange_dlx()).with(\u0026#34;no.#\u0026#34;); } } 编写接口\nimport org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class TopicController { @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(\u0026#34;/send\u0026#34;) public void sendMessage(){ rabbitTemplate.convertAndSend(\u0026#34;topic_exchange\u0026#34;,\u0026#34;yes.msg\u0026#34;,\u0026#34;发布了一条消息\u0026#34;); } } 编写 开启手动确认，以及自定义监听类\nimport com.shishiyi.listener.AckListener; import org.springframework.amqp.core.AcknowledgeMode; import org.springframework.amqp.rabbit.connection.ConnectionFactory; import org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MessageListenerConfig { @Autowired private AckListener ackListener; @Autowired private ConnectionFactory connectionFactory; @Bean public SimpleMessageListenerContainer simpleMessageListenerContainer(){ SimpleMessageListenerContainer simpleMessageListenerContainer = new SimpleMessageListenerContainer(connectionFactory); //消费者改为手动确认，默认为自动确认 simpleMessageListenerContainer.setAcknowledgeMode(AcknowledgeMode.MANUAL); //设置队列，参数可以设置多个队列名称 simpleMessageListenerContainer.setQueueNames(\u0026#34;topic_queue\u0026#34;); //设置自定义的监听类 simpleMessageListenerContainer.setMessageListener(ackListener); return simpleMessageListenerContainer; } } 执行业务出错，消息被拒绝(basic.reject/ basic.nack）并且requeue=false\nimport com.rabbitmq.client.Channel; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener; import org.springframework.stereotype.Component; @Component public class AckListener implements ChannelAwareMessageListener { @Override public void onMessage(Message message, Channel channel) throws Exception { long deliveryTag = message.getMessageProperties().getDeliveryTag(); try { //判断队列，可以针对不同队列，来执行不同的业务内容 if (\u0026#34;topic_queue\u0026#34;.equals(message.getMessageProperties().getConsumerQueue())){ //转换消息 System.out.println(new String(message.getBody())); //处理业务 System.out.println(\u0026#34;处理业务.........\u0026#34;); //除零出错，模拟执行业务出差错 int i = 1/0; } //手动确认，签收消息 channel.basicAck(deliveryTag,true); } catch (Exception e) { System.out.println(\u0026#34;出现异常，拒绝签收消息\u0026#34;); //拒绝签收消息，不重回队列requeue=false channel.basicNack(deliveryTag,true,false); } } } 启动测试，调用接口发送消息，查看rabbitmq管理页面，由于消费者方处理业务失败产生错误，拒绝签收消息，且不重回队列，则消息进入死信队列\n延迟队列 RabbitMQ很遗憾不支持原生的延迟队列，但是我们 可以根据TTL过期时间和死信队列组合实现延迟队列 功能\n生产方的配置类\npackage com.shishiyi.config; import org.springframework.amqp.core.*; import org.springframework.amqp.rabbit.connection.ConnectionFactory; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitmqConfig { //声明正常队列 @Bean public Queue queue(){ return QueueBuilder.durable(\u0026#34;topic_queue\u0026#34;) .deadLetterExchange(\u0026#34;topic_exchange_delay\u0026#34;) .deadLetterRoutingKey(\u0026#34;time.msg\u0026#34;) //设置队列过期时间,即到达指定时间发送消息 .ttl(5000) .build(); } //声明正常交换机 @Bean public TopicExchange exchange(){ return ExchangeBuilder.topicExchange(\u0026#34;topic_exchange\u0026#34;).build(); } //正常的队列和交换机进行绑定 @Bean public Binding binding(){ return BindingBuilder.bind(queue()).to(exchange()).with(\u0026#34;yes.#\u0026#34;); } //声明延迟队列 @Bean public Queue queue_delay(){ return QueueBuilder.durable(\u0026#34;topic_queue_delay\u0026#34;).build(); } //声明延迟交换机 @Bean public TopicExchange exchange_delay(){ return ExchangeBuilder.topicExchange(\u0026#34;topic_exchange_delay\u0026#34;).build(); } //延迟的队列和交换机进行绑定 @Bean public Binding binding_delay(){ return BindingBuilder.bind(queue_delay()).to(exchange_delay()).with(\u0026#34;time.#\u0026#34;); } } 编写接口\nimport org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class TopicController { @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(\u0026#34;/send\u0026#34;) public void sendMessage(){ SimpleDateFormat format = new SimpleDateFormat(\u0026#34;HH:mm:ss\u0026#34;); String current_time = format.format(new Date()); rabbitTemplate.convertAndSend(\u0026#34;topic_exchange\u0026#34;,\u0026#34;yes.msg\u0026#34;,\u0026#34;这是一条延时的消息,发送时间为：\u0026#34;+current_time); } } 编写消费者方\nimport org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component public class DelayReceiver { @RabbitListener(queues = \u0026#34;topic_queue_delay\u0026#34;) public void queue(Message message){ SimpleDateFormat format = new SimpleDateFormat(\u0026#34;HH:mm:ss\u0026#34;); String current_time = format.format(new Date()); System.out.println(\u0026#34;获取时间：\u0026#34;+current_time); System.out.println(\u0026#34;从延迟队列收到的消息：\u0026#34;+new String(message.getBody())); } } 启动测试，调用接口发送消息，查看消费者方控制台，5秒后会打印一条消息\n延迟队列（插件方式） 注：前提是通过docker 安装RabbitMQ-Management\n下载插件\nwget https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/3.9.0/rabbitmq_delayed_message_exchange-3.9.0.ez 复制到docker容器MQ的插件目录下\n注：docker cp 文件目录 docker容器id:容器内的路径\ndocker cp rabbitmq_delayed_message_exchange-3.9.0.ez 724766fbe93a:/opt/rabbitmq/plugins 进入到容器中\ndocker exec -it 724766fbe93a /bin/sh 开启插件\nrabbitmq-plugins enable rabbitmq_delayed_message_exchange 查看插件是否安装\nrabbitmq-plugins list 消费者方绑定方式实现延迟队列 创建接收消息类，使用@RabbitListener注解监听消息并同时绑定queue队列、exchange交换机、routing key\n@Component public class MqReceiver { /** * rabbitmq_delayed_message_exchange插件版延时队列 * @param msg * @param message * @param channel */ @RabbitListener(bindings= @QueueBinding(value = @Queue(value = \u0026#34;delay.queue\u0026#34;, durable = \u0026#34;true\u0026#34;), exchange = @Exchange(value = \u0026#34;delay.exchange\u0026#34;,type=ExchangeTypes.DIRECT, arguments=@Argument(name=\u0026#34;x-delayed-type\u0026#34;,value=\u0026#34;direct\u0026#34;),delayed=Exchange.TRUE), key =\u0026#34;delay.key\u0026#34;)) public void receiveDelay(String msg,Message message,Channel channel) { System.out.println(message.toString()); System.out.println(message.getMessageProperties().getReceivedDelay()); System.out.println(\u0026#34;-----------收到消息:\u0026#34;+msg+\u0026#34;,当前时间：\u0026#34;+new Date()); } } 发送消息\n@RestController public class TestContoller { @Autowired private AmqpTemplate amqpTemplate; @GetMapping(value = \u0026#34;/send/{exp}\u0026#34;) public String test(@PathVariable(\u0026#34;exp\u0026#34;) Integer exp) { String msg = \u0026#34;发送时间：\u0026#34;+new Date(); amqpTemplate.convertAndSend(MQConstants.DELAY_EXCHANGE,MQConstants.THEATRE_DELAY_KEY,msg,message -\u0026gt; { message.getMessageProperties().setDelay(exp);// 单位 毫秒 return message; }); return \u0026#34;---------sendTime:\u0026#34;+new Date(); } } 然后启动项目，可以看到rabbitMQ控制台显示出了定义的exchange，注意type显示为x-delayed-message\n注：注意插件版的死信队列Features字段不会显示DLX\n调用接口，定义10秒的延迟\n","permalink":"http://shaoyi.cc/posts/blog/mq/rabbitmq/rabbitmq/","summary":"Docker 安装RabbitMQ 这里注意获取镜像的时候要获取management版本的，不要获取last版本的，management版本的才带有管理界","title":"消息中间件之RabbitMQ"},{"content":"ActiveMQ安装（Docker环境下） 首先在docker搜索ActiveMQ，发现webcenter/activemq 这个版本使用是最多的\n然后选择版本，下载activeMQ\n查看镜像，配置好activemq容器的后台端口（61616）和前台端口（8161）的映射关系，并启动它\n浏览器访问，如下图，便安装完成\nJMS实现消息的生产者和消费者 队列的方式 生产者：\nimport org.apache.activemq.ActiveMQConnectionFactory; import javax.jms.*; public class JmsProduce { private static final String ACTIVEMQ_URL=\u0026#34;tcp://服务器公网ip:后台映射端口号\u0026#34;; private static final String QUEUE_NAME=\u0026#34;myQueue\u0026#34;; public static void main(String[] args) throws JMSException { //创建连接工厂，指定active的url链接，不指定用户名和密码就是默认的。 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); //创建工厂后获取链接，并启动 Connection connection = connectionFactory.createConnection(); connection.start(); //创建会话，有两个参数，分别是事务和签收机制 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建目的地（这里为队列方式） Destination destination = session.createQueue(QUEUE_NAME); //创建消息的生产者 MessageProducer messageProducer = session.createProducer(destination); //生产4条消息 for (int i = 1; i \u0026lt; 5; i++) { //创建消息内容 TextMessage message = session.createTextMessage(\u0026#34;第\u0026#34; + i + \u0026#34;条消息\u0026#34;); //发送消息 messageProducer.send(message); } //关闭资源 messageProducer.close(); session.close(); connection.close(); System.out.println(\u0026#34;消息发送完成！\u0026#34;); } } 执行后的结果：\n消费者（receive()方法获取信息）：\nimport org.apache.activemq.ActiveMQConnectionFactory; import javax.jms.*; public class JmsConsumer { private static final String ACTIVEMQ_URL=\u0026#34;tcp://服务器公网ip:后台映射端口号\u0026#34;; private static final String QUEUE_NAME=\u0026#34;myQueue\u0026#34;; public static void main(String[] args) throws JMSException { //创建连接工厂，指定active的url链接，不指定用户名和密码就是默认的。 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); //创建工厂后获取链接，并启动 Connection connection = activeMQConnectionFactory.createConnection(); connection.start(); //创建会话，有两个参数，分别是事务和签收机制 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建目的地(这里为队列方式) Destination destination = session.createQueue(QUEUE_NAME); //创建消息的生产者 MessageConsumer messageConsumer = session.createConsumer(destination); while (true){ //读取消息 TextMessage textMessage = (TextMessage)messageConsumer.receive(); if (null !=textMessage){ //获取消息内容并打印 System.out.println(\u0026#34;消费者接受的消息: \u0026#34;+textMessage.getText()); }else { break; } } //关闭资源 messageConsumer.close(); session.close(); connection.close(); } } 执行结果：\n消费者（监听器MessageListener方式获取信息）\nimport org.apache.activemq.ActiveMQConnectionFactory; import javax.jms.*; import java.io.IOException; public class JmsConsumer02 { private static final String ACTIVEMQ_URL=\u0026#34;tcp://服务器公网ip:后台映射端口号\u0026#34;; private static final String QUEUE_NAME=\u0026#34;myQueue\u0026#34;; public static void main(String[] args) throws JMSException, IOException { //创建连接工厂，指定active的url链接，不指定用户名和密码就是默认的。 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); //创建工厂后获取链接，并启动 Connection connection = activeMQConnectionFactory.createConnection(); connection.start(); //创建会话，有两个参数，分别是事务和签收机制 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建目的地(这里为队列方式) Destination destination = session.createQueue(QUEUE_NAME); //创建消息的生产者 MessageConsumer messageConsumer = session.createConsumer(destination); messageConsumer.setMessageListener((message) -\u0026gt; { if (null != message \u0026amp;\u0026amp; message instanceof TextMessage){ TextMessage textMessage = (TextMessage) message; try { System.out.println(\u0026#34;消费者接受的消息: \u0026#34;+textMessage.getText()); } catch (JMSException e) { e.printStackTrace(); } } }); System.in.read(); //防止消息还没有读取到就关闭资源了 //关闭资源 messageConsumer.close(); session.close(); connection.close(); } } 消费者获取消息的方式\nreceive() 方法：该方法是同步阻塞的，如果调用者（队列或者订阅方）没有接受到消息，就会一直等待\n除此之外它有一个重载方法 receive(long timeout) ，参数表示的是 等待的超时时间（毫秒），在等待时间内没有接受到消息就自动停止\nsetMessageListener(MessageListener listener) 方法：该方法是异步非阻塞的，而方法参数类型是MessageListener接口，这个接口里只定义了一个用于处理接收到的消息的onMessage方法，该方法只接收一个Message参数监听器。当消息到达之后，会自动调用onMessage方法获取信息\n消费者的三种情况\n先启动生产者，生产消息，然后再启动一个消费者，是否可以正常消费信息 ？\n答案：可以的 还是先启动生产者，生产消息，再分别启动两个消费者，后一个启动的消费者可以消费到消息吗 ？\n答案：否，后一个启动的消费者是消费不到的消息，消息都被前一个启动的消息者消费完了 先启动两个消费者，再启动生产者生产6条消息，结果如何 ？\n答案：消息被平分，两个消费者一人一半，分别消费3条消息 发布订阅方式 生产者：\nimport org.apache.activemq.ActiveMQConnectionFactory; import javax.jms.*; public class JmsProduce_Topic { private static final String ACTIVEMQ_URL=\u0026#34;tcp://服务器公网ip:后台映射端口号\u0026#34;; private static final String TOPIC_NAME=\u0026#34;myTopic\u0026#34;; public static void main(String[] args) throws JMSException { //创建连接工厂，指定active的url链接，不指定用户名和密码就是默认的。 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); //创建工厂后获取链接，并启动 Connection connection = connectionFactory.createConnection(); connection.start(); //创建会话，有两个参数，分别是事务和签收机制 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建目的地（这里为发布订阅方式） Destination destination = session.createTopic(TOPIC_NAME); //创建消息的生产者 MessageProducer messageProducer = session.createProducer(destination); //生产4条消息 for (int i = 1; i \u0026lt; 5; i++) { //创建消息内容 TextMessage message = session.createTextMessage(\u0026#34;第\u0026#34; + i + \u0026#34;条消息\u0026#34;); //发送消息 messageProducer.send(message); } //关闭资源 messageProducer.close(); session.close(); connection.close(); System.out.println(\u0026#34;消息发送完成！\u0026#34;); } } ​\t发布订阅的方式和队列方式， 从生产者的代码可以发现，两者是一样的，唯一不同的就是，创建目的地的方法不一样，队列是createQueue(String queueName)，而发布订阅是createTopic(String topicName)。同样的，消费者的代码和队列也是一样的\n消费者\nimport org.apache.activemq.ActiveMQConnectionFactory; import javax.jms.*; import java.io.IOException; public class JmsConsumer_Topic { private static final String ACTIVEMQ_URL=\u0026#34;tcp://服务器公网ip:后台映射端口号\u0026#34;; private static final String TOPIC_NAME=\u0026#34;myTopic\u0026#34;; public static void main(String[] args) throws JMSException, IOException { //创建连接工厂，指定active的url链接，不指定用户名和密码就是默认的。 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(); //创建工厂后获取链接，并启动 Connection connection = activeMQConnectionFactory.createConnection(); connection.start(); //创建会话，有两个参数，分别是事务和签收机制 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建目的地（这里为发布订阅方式） Destination destination = session.createTopic(TOPIC_NAME); //创建消息的生产者 MessageConsumer messageConsumer = session.createConsumer(destination); //通过监听器，接受消息 messageConsumer.setMessageListener((message) -\u0026gt; { if (null != message \u0026amp;\u0026amp; message instanceof TextMessage) { try { TextMessage textMessage = (TextMessage) message; System.out.println(\u0026#34;消费者接受的消息: \u0026#34; + textMessage.getText()); } catch (JMSException e) { e.printStackTrace(); } } }); System.in.read();//阻塞等待 //关闭资源 messageConsumer.close(); session.close(); connection.close(); } } ​\t不过要注意的是，发布订阅的模式，要先启用订阅方，也就是消费者方，再启动发布方（生产者）。否则，就类似微信公众号一样，没有人订阅，生产方发布消息是没有人接受的到，会被丢弃。这种则是废消息。\n队列和发布订阅两者对比 比 较 项 目 Topic （发布订阅）模式 Queue （队列）模式 工 作 模 式 “订阅-发布”模式，如果当前没有订阅 者，消息将会被丢弃，如果有多个订阅 者，那么这些订阅者都会收到消息。 负载均衡 模式，如果当前没有消费者，消息也不会丢弃，如果有多个消费者，那么一条消息 也只会发送给其中一个消费者，并且要求消费者ack信息 有 无 状 态 无状态 Queue 数据默认会在 mq 服务器上以文件形式 保存，比如 Active MQ 一般保存在 $AMQ_HOME\\data\\kr-store\\data下面，也可 以配置成DB存储 传 递 完 整 性 如果没有订阅者，消息会被丢弃 消息不会丢弃 处 理 效 率 由于消息要按照订阅者的数量进行复 制，所以处理性能会随着订阅者的增加 而明显降低，并且还要结合不同消息协 议自身的性能差异 由于一条消息只发送给一个消费者，所以就算 消费者再多，性能也不会有明显降低。当然不 同消息协议的具体性能也是有差异的。 JMS ​\tJMS是Java EE的一个面向消息中间件的一套规范，具体需要靠厂商的产品实现\n消息的三种部分 消息头 在生产者方，消息的API看出可以针对每一条消息设置不同的消息头属性 如果不想为每一条消息单独设置消息头属性，可以通过Send()方法的重载，批处理消息的消息头属性 从批处理消息头属性和单独设置消息头属性两者结合来看，主要介绍五个消息头属性： JMSDestination： 消息发送的目的地，主要是指 Queue 和 Topic\nJMSDeliveryMode： 持久模式和非持久模式，可设置的参数为DeliveryMode.NON_PERSISTENT(非持久) 和 DeliveryMode.PERSISTENT(持久)\n一条持久性的消息：应该被传送 “一次仅仅一次”，这就意味着如果JMS 提供者出现故障，该消息并不会丢失，它会在服务器恢复之后再次传递消息。 一条非持久的消息：多会传送一次，这意味着服务器出现故障，该消息将永久丢失。\nJMSPriority ： 消息优先级，从0 ~ 9 十个级别，0 ~ 4 是普通消息，5 ~ 9是加急消息。\nJMS 不要求 MQ 严格按照这十个优先级发送消息，但必须保证加急消息要先于普通消息到达，默认是4 级。\nJMSExpiration： 可以设置消息在一定时间后过期，默认是永不过期。消息过期时间，等于Destination的send方法中的timeToLive值加上发送时刻的GMT时间\n值。 如果timeToLive值等于零，则 JMSExpiration 被设为零，表示该消息永不过期。如果发送后，在消息过期时间之后消息还没有被发送到目的地，则该消息被清除。\nJMSMessageID ： 唯一识别每个消息的标识，由MQ产生。\n消息体 封装具体的消息数据，发送和接收的消息体类型必须一致对应！\n五种消息体格式：\nTextMessage： 普通字符串消息，包含一个String 。\nMapMessage： 一个Map类型的消息，key为String类型，而值为Java的基本类型。\nBytesMessage ： 二进制数组消息，包含一个byte[] 。\nStreamMessage ： Java数据流消息，用标准流操作来顺序的填充和读取。\nObjectMessage ：对象消息，包含一个可序列化的 Java 对象。\n消息属性 如果需要除消息头字段以外的值，那么可以使用消息属性！\n识别、去重、重点标注等操作非常有用的方法！\n消息属性是以属性名和属性值对的形式指定的。可以将属性是为消息头的扩展，属性指定一些消息头没有包括的附加信息，比如可以在属性里指定消息选择器。\n以Property结尾：\n消息的可靠性 持久性 队列 //创建目的地（这里为队列方式） Destination destination = session.createQueue(QUEUE_NAME); //创建消息的生产者 MessageProducer messageProducer = session.createProducer(destination); // 非持久化 ：服务器宕机，则消息不能恢复 messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); // 持久化 ：服务器宕机，消息可以恢复 messageProducer.setDeliveryMode(DeliveryMode.PERSISTENT); 队列是否设置为持久，可以通过setDeliveryMode(int deliveryMode)方法设置，默认为持久\n持久性 发布订阅 发布方（生产者），顺序与之前有一点不同，需要设定先持久化，在启动连接\n测试代码：\nimport org.apache.activemq.ActiveMQConnectionFactory; import javax.jms.*; public class JmsProduce_Topic_DeliveryMode { private static final String ACTIVEMQ_URL=\u0026#34;tcp://服务器公网ip:后台映射端口号\u0026#34;; private static final String TOPIC_NAME=\u0026#34;my_topic_persist\u0026#34;; public static void main(String[] args) throws JMSException { ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); Connection connection = connectionFactory.createConnection(); Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); Topic topic = session.createTopic(TOPIC_NAME); MessageProducer messageProducer = session.createProducer(topic); //设置发布方为 持久 messageProducer.setDeliveryMode(DeliveryMode.PERSISTENT); //设定为持久后，然后连接 connection.start(); for (int i = 1; i \u0026lt;=3; i++) { TextMessage message = session.createTextMessage(\u0026#34;第\u0026#34; + i + \u0026#34;条消息\u0026#34;); messageProducer.send(message); } //关闭资源 messageProducer.close(); session.close(); connection.close(); System.out.println(\u0026#34;消息发送完成！\u0026#34;); } } 订阅方（消费者）测试代码：\nimport org.apache.activemq.ActiveMQConnectionFactory; import javax.jms.*; public class JmsConsumer_Topic_DeliveryMode { private static final String ACTIVEMQ_URL=\u0026#34;tcp://服务器公网ip:后台映射端口号\u0026#34;; private static final String TOPIC_NAME=\u0026#34;my_topic_persist\u0026#34;; public static void main(String[] args) throws JMSException { ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); Connection connection = connectionFactory.createConnection(); //订阅方的id connection.setClientID(\u0026#34;001\u0026#34;); Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); Topic topic = session.createTopic(TOPIC_NAME); //创建持久的订阅方 TopicSubscriber topicSubscriber = session.createDurableSubscriber(topic, \u0026#34;十十乙\u0026#34;); //持久化后，再进行连接 connection.start(); Message message = topicSubscriber.receive(); while (null != message){ TextMessage textMessage = (TextMessage)message; System.out.println(\u0026#34;订阅方收到的消息：\u0026#34;+textMessage.getText()); message = topicSubscriber.receive(3000L); } topicSubscriber.close(); session.close(); connection.close(); } } 先启动订阅方，再启动发布方，到ActiveMQ前台的Subscribers查看\n启动前情况：\n启动订阅方后情况：\n启动生产方 后：\n订阅方停止后，会被列 离线的一栏去：\n如果这时，发布者再次发布消息，订阅方重启启动是否能接收到消息\n再次启动订阅方(不停止)后\n小结：\n​\t第一次，一定要先启动订阅方，之后启动发布方，发布消息。这时不论订阅方在不在线，都可以接受到消息，不在线，重新启动后会接受没有收到过的消息接受下来\n事务 事务偏向于生产者、签收偏向于消费者\n//创建会话，有两个参数，分别是事务和签收机制 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); 事务只有两个值，true和false\n生产者一方\n当值为false时，消息会被自动发送到目的地\n当值为true时，需要在调用send()方法后，调用commit()方法，手动提交\n消费者一方\n当值为false时，消息只会被消费一次\n当值为true时，消息会被重复消费，且在目的地中，消息不会出队的，即未被消费\n测试：\n//创建会话，开启事务 Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE); try { //OK,就提交 session.commit(); } catch (JMSException e) { //error,就回滚 session.rollback(); }finally { //关闭资源 } 签收机制 签收针对的是消费者一方，分为以下四种\npublic interface Session extends Runnable { static final int AUTO_ACKNOWLEDGE = 1; //自动签收（默认） static final int CLIENT_ACKNOWLEDGE = 2;\t//手动签收，需要调用 message.acknowledge(); 进行签收，否则也会导致重复消费 static final int DUPS_OK_ACKNOWLEDGE = 3;\t//自动批量确认 static final int SESSION_TRANSACTED = 0;\t//这个是配合事务，当事务开启则选择这个，主要是一个语法的一个规范而已 当事务没有开启时 ： 即非事务，消息的确认情况 则以签收机制为主\n当事务开始时 ： 即事务情况下，消息的确认以事务为主，即是否commit的为主，不用管签收机制的情况。\n注：常用的签收模式 主要以自动签收（AUTO_ACKNOWLEDGE）和手动签收（CLIENT_ACKNOWLEDGE）为主\nSpringBoot结合ACtiveMQ 队列模式 1、导入maven依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--activemq的依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-activemq\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 2、编写application.properties配置文件\nserver.port=8888 # 配置activemq的链接，用户名和密码 spring.activemq.broker-url=tcp://服务器公网ip:端口号 spring.activemq.user=admin spring.activemq.password=admin #配置是否为发布订阅模式 #false为队列（默认） #ture为发布订阅 spring.jms.pub-sub-domain=false #队列名称（自定义标签） myqueue=activemq_springboot_queue 3、编写配置类\npackage com.shishiyi.config; import org.apache.activemq.command.ActiveMQQueue; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.jms.Queue; @Configuration public class ActiveMQConfig { //注入队列名称 @Value(\u0026#34;${myqueue}\u0026#34;) private String myQueue_name; //向spring容器导入队列对象 @Bean public Queue queue(){ return new ActiveMQQueue(myQueue_name); } } 4、编写队列的消息生产者Produce\npackage com.shishiyi.queue; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jms.core.JmsMessagingTemplate; import org.springframework.stereotype.Component; import javax.jms.Queue; @Component public class QueueProduce { @Autowired private JmsMessagingTemplate jmsMessagingTemplate; @Autowired private Queue queue_name; public void produceSend(){ //发送消息 jmsMessagingTemplate.convertAndSend(queue_name,\u0026#34;生产者生产消息\u0026#34;); } } 5、编写controller类，并访问接口\npackage com.shishiyi.controller; import com.shishiyi.queue.QueueProduce; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class QueueProduceController { @Autowired private QueueProduce queueProduce; @GetMapping(\u0026#34;/queuesend\u0026#34;) public void queueSend(){ queueProduce.produceSend(); System.out.println(\u0026#34;消息发送成功\u0026#34;); } } 查看ActiveMQ的前台，消息已经发送到队列了\n6、编写队列的消费者\npackage com.shishiyi.queue; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jms.annotation.JmsListener; import org.springframework.jms.core.JmsMessagingTemplate; import org.springframework.stereotype.Component; import javax.jms.JMSException; import javax.jms.Message; import javax.jms.TextMessage; @Component public class QueueConsumer { @Autowired private JmsMessagingTemplate jmsMessagingTemplate; //采用监听器的方式获取消息 @JmsListener(destination = \u0026#34;${myqueue}\u0026#34;) public void receive(Message message) throws JMSException { if (null !=message \u0026amp;\u0026amp; message instanceof TextMessage){ TextMessage textMessage = (TextMessage)message; System.out.println(\u0026#34;消费者已经接受到了\u0026#34;+textMessage.getText()); } } } 删除之前入队的信息，然后重新启动 启动类，再次访问接口，并查看ActiveMQ的前台和打印台\n订阅发布模式 1、导入maven依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-activemq\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 2、编写application.properties配置文件\nserver.port=7777 # 配置activemq的链接，用户名和密码 spring.activemq.broker-url=tcp://服务器公网ip:端口号 spring.activemq.user=admin spring.activemq.password=admin #配置是否为发布订阅模式 #false为队列（默认） #ture为发布订阅 spring.jms.pub-sub-domain=true #topic名称 mytopic=activemq_springboot_topic 3、编写配置类\npackage com.shishiyi.config; import org.apache.activemq.command.ActiveMQTopic; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.jms.Topic; @Configuration public class ActiveMQConfig { @Value(\u0026#34;${mytopic}\u0026#34;) private String myTopic; @Bean public Topic topic(){ return new ActiveMQTopic(myTopic); } } 4、编写主题的消息生产者（发布方）\npackage com.shishiyi.topic; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jms.core.JmsMessagingTemplate; import org.springframework.stereotype.Component; import javax.jms.Topic; @Component public class TopicProduce { @Autowired private JmsMessagingTemplate jmsMessagingTemplate; @Autowired private Topic topic; public void topicSend(){ jmsMessagingTemplate.convertAndSend(topic,\u0026#34;发布方向主题发布的消息\u0026#34;); System.out.println(\u0026#34;消息发送成功\u0026#34;); } } 5、编写controller类\npackage com.shishiyi.controller; import com.shishiyi.topic.TopicProduce; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class TopicProduceController { @Autowired private TopicProduce topicProduce; @GetMapping(\u0026#34;/topicSend\u0026#34;) public void topicSend(){ topicProduce.topicSend(); } } 6、编写主题的消费者（订阅方）\npackage com.shishiyi.topic; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jms.annotation.JmsListener; import org.springframework.jms.core.JmsMessagingTemplate; import org.springframework.stereotype.Component; import javax.jms.*; @Component public class TopicConsumer { @Autowired private JmsMessagingTemplate jmsMessagingTemplate; @JmsListener(destination = \u0026#34;${mytopic}\u0026#34;) public void receive(Message message) throws JMSException { if (null != message \u0026amp;\u0026amp; message instanceof TextMessage){ TextMessage textMessage = (TextMessage) message; System.out.println(\u0026#34;订阅方收到的消息：\u0026#34;+textMessage.getText()); } } } 7、启动主启动类，访问接口，让发布方生产消息，并查看ActiveMQ的前台和打印台\n定时的订阅发布模式\n让发布方每过5秒，发送一次消息\n//创建定时任务 package com.shishiyi.topic; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jms.core.JmsMessagingTemplate; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; import javax.jms.Topic; @Component public class TopicProduce { @Autowired private JmsMessagingTemplate jmsMessagingTemplate; @Autowired private Topic topic; public void topicSend(){ jmsMessagingTemplate.convertAndSend(topic,\u0026#34;发布方向主题发布的消息\u0026#34;); System.out.println(\u0026#34;消息发送成功\u0026#34;); } //创建定时任务，每隔5秒发布消息 @Scheduled(fixedRate = 5000L) public void scheduled(){ topicSend(); } } 添加 @EnableScheduling 注解，发现定时任务让它后台执行\n修改主题的消费者（订阅方），添加LocalDateTime.now()方法，方便在控制台查看\npackage com.shishiyi.topic; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jms.annotation.JmsListener; import org.springframework.jms.core.JmsMessagingTemplate; import org.springframework.stereotype.Component; import javax.jms.*; import java.time.LocalDateTime; @Component public class TopicConsumer { @Autowired private JmsMessagingTemplate jmsMessagingTemplate; @JmsListener(destination = \u0026#34;${mytopic}\u0026#34;) public void receive(Message message) throws JMSException { if (null != message \u0026amp;\u0026amp; message instanceof TextMessage){ TextMessage textMessage = (TextMessage) message; System.out.println(\u0026#34;订阅方收到的消息：\u0026#34;+textMessage.getText()+ \u0026#34;时间为：\u0026#34; +LocalDateTime.now()); } } } 启动程序，查看控制台打印内容，以及（同一时间点内）查看ActiveMQ的前台\nActiveMQ传输协议 在连接activemq时，默认是用TCP连接，那Activemq是否还支持其它协议吗？\n查看activemq的conf文件夹下的activemq.xml\n可以看出，除了支持默认的TCP协议，还支持 amqp ，stomp，mqtt，ws等协议，而且协议对应的端口号也不一样，这就是用TCP连接时，端口号是61616的原因了。\n从activemq前台也可以查看出来\n如果想配置其它协议，可以查看官网的文档\nhttp://activemq.apache.org/configuring-version-5-transports\n配置NIO协议 从官网的文档得知，配置NIO协议，只需要修改activemq.xml文件\n\u0026lt;!--添加一段即可--\u0026gt; \u0026lt;transportConnectors\u0026gt; \u0026lt;transportConnector name=\u0026#34;nio\u0026#34; uri=\u0026#34;nio://0.0.0.0:61617\u0026#34;/\u0026gt; \u0026lt;/\u0026lt;transportConnectors\u0026gt; 重启activemq（重启容器），查看activemq前台\n修改代码的连接方式，并测试\n//由于安装的activemq是docker容器，添加的nio协议端口是61617，所以端口要提前映射好，否则会连不上 private static final String ACTIVEMQ_URL=\u0026#34;nio://47.115.151.184:61617\u0026#34;; private static final String QUEUE_NAME=\u0026#34;myQueue_NIO\u0026#34;; 查看前台\nActiveMQ持久化 持久化不同于之前的持久性，持久化是以防服务器本身挂了，重启服务器也可以恢复消息\nActiveMQ目前默认的持久化方式是KahaDB，此外还有JDBC， LevelDB等，不过它们大体上的逻辑是一样，消息中心接受到消息。会把消息备份存储起来。\nKahaDB(默认) KahaDB：这个5.4版本之后出现的默认的持久化方式， KahaDB的持久化机制是基于日志文件，索引和缓存。\n从activemq.xml配置文件中可以得知\n它是把数据存储在activemq的data目录下的kahadb文件夹中\n在这个文件夹中会有四个文件来完成消息持久化\ndb.data 它是消息的索引文件，本质上是B-Tree（B树），使用B-Tree作为索引指向db-*.log里面存储的消息 db.redo 用来进行消息恢复 db-*.log 存储消息内容。新的数据以APPEND的方式追加到日志文件末尾。属于顺序写入，因此消息存储是比较快的。默认是32M，达到阀值会自动递增文 件，文件名按照数字进行编号，如 db-1.log、db-2.log、\u0026hellip;.. lock 文件 锁，写入当前获得kahadb读写权限的broker ，用于在集群环境下的竞争处理 KahaDB配置官网链接： http://activemq.apache.org/kahadb\nLevelDB 这种文件系统是从ActiveMQ 5.8 之后引进的，它和 KahaDB 非常相似，也是基于文件的本地数据库存 储形式，但是它提供比 KahaDB更快的持久性。\n但它不使用自定义 B-Tree 实现来索引预写日志，而是使用基于LevelDB的索引。\n可是为什么LeavelDB 更快，并且5.8 以后就支持，为什么还是默认 KahaDB 引擎，因为 activemq 官网本身没有定论，LeavelDB 之后又出了可复制的\nLeavelDB 比LeavelDB 更性能更优越，但需要基于 ZooKeeper 所以这些官方还没有定论，仍旧使用 KahaDB。\n默认配置：\n\u0026lt;broker brokerName=\u0026#34;broker\u0026#34; ... \u0026gt; ... \u0026lt;persistenceAdapter\u0026gt; \u0026lt;levelDB directory=\u0026#34;activemq-data\u0026#34;/\u0026gt; \u0026lt;/persistenceAdapter\u0026gt; ... \u0026lt;/broker\u0026gt; LevelDB配置官网链接： http://activemq.apache.org/leveldb-store\nJDBC 看名字就知道和数据库有关，所以JDB的持久化就是把消息备份到数据库中\n由于用docker比较麻烦，所以直接改为windows本地测试\n首先下载activemq的windows版本，http://activemq.apache.org/components/classic/download/\n然后下载mysql的驱动包，\n把mysql驱动包丢到activemq的lib下\n打开activemq的conf目录下的activemq.xml文件，配置内容：\n\u0026lt;!-- Configure message persistence for the broker. The default persistence mechanism is the KahaDB store (identified by the kahaDB tag). For more information, see: http://activemq.apache.org/persistence.html \u0026lt;persistenceAdapter\u0026gt; \u0026lt;kahaDB directory=\u0026#34;${activemq.data}/kahadb\u0026#34;/\u0026gt; \u0026lt;/persistenceAdapter\u0026gt; 屏蔽之前的持久化 --\u0026gt; \u0026lt;!--改用mysql方式--\u0026gt; \u0026lt;persistenceAdapter\u0026gt; \u0026lt;jdbcPersistenceAdapter dataSource=\u0026#34;#mysqlDataSource\u0026#34; createTablesOnStartup=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/persistenceAdapter\u0026gt; 参数解释：\ndataSource： 表示的是引用的数据源名称\ncreateTablesOnStartup： 表示启动的时候是否去创建表，一般第一次为true,之后改为false\n接着由于指定了数据源，所以需要在activemq.xml配置一个数据源，不过要注意位置\n\u0026lt;bean id=\u0026#34;mysqlDataSource\u0026#34; class=\u0026#34;org.apache.commons.dbcp.BasicDataSource\u0026#34; destroy-method=\u0026#34;close\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/activemq?relaxAutoCommit=true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 然后创建好数据库，数据库名字与数据源链接的要一致\n测试：\nQueue\n//生产者 public class JmsProduce { private static final String ACTIVEMQ_URL=\u0026#34;tcp://127.0.0.1:61616\u0026#34;; private static final String QUEUE_NAME=\u0026#34;queue_jdbc_mysql\u0026#34;; public static void main(String[] args) throws JMSException { ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); Connection connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); Destination destination = session.createQueue(QUEUE_NAME); MessageProducer messageProducer = session.createProducer(destination); //一定要开启持久化 messageProducer.setDeliveryMode(DeliveryMode.PERSISTENT); for (int i = 1; i \u0026lt; 5; i++) { TextMessage message = session.createTextMessage(\u0026#34;第\u0026#34; + i + \u0026#34;条消息\u0026#34;); messageProducer.send(message); } //关闭资源 messageProducer.close(); session.close(); connection.close(); System.out.println(\u0026#34;消息发送完成！\u0026#34;); } } 启动后，分别查看数据库和前台：\n//消费者 public class JmsConsumer { private static final String ACTIVEMQ_URL=\u0026#34;tcp://127.0.0.1:61616\u0026#34;; private static final String QUEUE_NAME=\u0026#34;queue_jdbc_mysql\u0026#34;; public static void main(String[] args) throws JMSException { ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); Connection connection = activeMQConnectionFactory.createConnection(); connection.start(); Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); Destination destination = session.createQueue(QUEUE_NAME); MessageConsumer messageConsumer = session.createConsumer(destination); while (true){ TextMessage textMessage = (TextMessage)messageConsumer.receive(); if (null !=textMessage){ //获取消息内容并打印 System.out.println(\u0026#34;消费者接受的消息: \u0026#34;+textMessage.getText()); }else { break; } } //关闭资源 messageConsumer.close(); session.close(); connection.close(); } } 启动消费者查看数据库和前台：\nQueue 小结：\n​\t在点对点类型中，当DeliveryMode设置为NON_PERSISTENCE 时，消息被保存在内存中； 当DeliveryMode设置为PERSISTENCE 时，消息被保存在Broker的相应的文件或者数据库中。而且点对点类型中消息一旦被Consumer消费就从Broker中删除\nTopic\n//发布方 public class JmsProduce_Topic { private static final String ACTIVEMQ_URL=\u0026#34;tcp://127.0.0.1:61616\u0026#34;; private static final String TOPIC_NAME=\u0026#34;topic_jdbc_mysql\u0026#34;; public static void main(String[] args) throws JMSException { ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); Connection connection = connectionFactory.createConnection(); Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); Topic topic = session.createTopic(TOPIC_NAME); MessageProducer messageProducer = session.createProducer(topic); //设置发布方为 持久 messageProducer.setDeliveryMode(DeliveryMode.PERSISTENT); //设定为持久后，然后连接 connection.start(); for (int i = 1; i \u0026lt;=3; i++) { TextMessage message = session.createTextMessage(\u0026#34;第\u0026#34; + i + \u0026#34;条消息\u0026#34;); messageProducer.send(message); } //关闭资源 messageProducer.close(); session.close(); connection.close(); System.out.println(\u0026#34;消息发送完成！\u0026#34;); } } //订阅方 public class JmsConsumer_Topic_DeliveryMode { private static final String ACTIVEMQ_URL=\u0026#34;tcp://127.0.0.1:61616\u0026#34;; private static final String TOPIC_NAME=\u0026#34;topic_jdbc_mysql\u0026#34;; public static void main(String[] args) throws JMSException { ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); Connection connection = connectionFactory.createConnection(); //订阅方的id connection.setClientID(\u0026#34;001\u0026#34;); Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); Topic topic = session.createTopic(TOPIC_NAME); //创建持久的订阅方 TopicSubscriber topicSubscriber = session.createDurableSubscriber(topic, \u0026#34;十十乙\u0026#34;); //持久化后，再进行连接 connection.start(); Message message = topicSubscriber.receive(); while (null != message){ TextMessage textMessage = (TextMessage)message; System.out.println(\u0026#34;订阅方收到的消息：\u0026#34;+textMessage.getText()); message = topicSubscriber.receive(); } topicSubscriber.close(); session.close(); connection.close(); } } 先启动订阅方然后再启动发布方，查看数据库和前台：\nTopic 小结：\n一定要先启动消费订阅然后再启动生产，消息会被保留在 activemq_msgs表中消费完毕也不会删除，而订阅关系在 acks 表 中。\n","permalink":"http://shaoyi.cc/posts/blog/mq/activemq/activemq/","summary":"ActiveMQ安装（Docker环境下） 首先在docker搜索ActiveMQ，发现webcenter/activemq 这个版本使用是最多","title":"消息中间件之ActiveMQ"},{"content":"Java锁 独占锁（写锁）：\n指该锁一次只能被一个线程锁持有。对于ReentranrLock和 Synchronized 而言都是独 占锁。\n共享锁（读锁）：\n该锁可被多个线程所持有。\n公平锁：\n是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。\n非公平锁：\n是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比现申请的线程 优先获取锁。不断尝试获取锁，如果尝试失败就像公平锁一样等着。\nReentrantLock锁可以通过创建时的构造方法来指定为公平锁还是非公平锁，默认为非公平锁\n源码如下：\n对于Synchronized而言，也是一种非公平锁。\n可重入锁（也叫递归锁）：\n指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法 获取锁的时候，在进入内层方法会自动获取锁。也就是说，线程可以进入任何一个它已经拥有的锁，所同步着的代码块。 就好比，打开家的大门，也可以打开家里房间的门。\nReentrantLock、Synchronized 就是一个典型的可重入锁；\n自旋锁（spinlock）： 是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下 文切换的消耗，缺点是循环会消耗CPU。\n死锁：\n是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干 涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性 就很低，否者就会因为争夺有限的资源而陷入死锁。\n此外，还有乐观锁，悲观锁\nCallable Java中获取多线程 除继承Thread类和实现Runnable接口 外的，第三种方式\n与Runnable不同之处：\n从源码可以发现，是否有返回值，是否抛异常，实现方法不同，一个是call()方法，一个是run()方法\n可是Thread类没有关于Callable参数的方法，这点JDK源码已经表明了\n所以需要一个中间类来实现Callable接口与Thread类的关系，这个类需要实现Runnable接口（这样才能把对象传给Thread类），且构造方法参数有Callable接口类型参数（这样才能把Callable接口的实现类的对象丢进来）；\n查看Jdk文档以及查看中间类的源码得知，FutureTask类可以做这个中间类，来完成Callable接口的call()方法调用\n测试代码：\nimport java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; import java.util.concurrent.TimeUnit; public class CallableTest { public static void main(String[] args) throws ExecutionException, InterruptedException { Callable callable = new MyCallable(); //把Callable实现类传给FutureTask类 FutureTask futureTask = new FutureTask\u0026lt;\u0026gt;(callable); //再把FutureTask对象传给Thread类，调用start()方法，启动线程 new Thread(futureTask,\u0026#34;callable线程\u0026#34;).start(); //想得到call()方法执行后的返回值，可以调用FutureTask类的get()方法 String o = (String)futureTask.get(); System.out.println(o); } } /** * Callable接口的实现类 */ class MyCallable implements Callable\u0026lt;String\u0026gt; { @Override public String call() throws Exception { System.out.println(Thread.currentThread().getName()+\u0026#34;===\u0026gt;call()方法被调用了\u0026#34;); TimeUnit.SECONDS.sleep(3); return \u0026#34;ok\u0026#34;; } } Lock 传统的Synchronized锁实现 public class LockTest { public static void main(String[] args) { Token token = new Token(); /** * 开启了三个线程去卖票 */ new Thread(()-\u0026gt;{ for (int i = 1; i \u0026lt;=300 ; i++) { token.sale(); } },\u0026#34;A\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 1; i \u0026lt;=300 ; i++) { token.sale(); } },\u0026#34;B\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 1; i \u0026lt;=300 ; i++) { token.sale(); } },\u0026#34;C\u0026#34;).start(); } } class Token{ //资源类 private int ticket=300; //总票数 public synchronized void sale(){ if (ticket\u0026gt;0){ ticket--; System.out.println(Thread.currentThread().getName()+\u0026#34;卖了一张票，当前还有\u0026#34;+ ticket + \u0026#34;票\u0026#34;); } } } Lock锁实现 import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class LockTest { public static void main(String[] args) { Token token = new Token(); /** * 利用lock锁 * 开启了三个线程去卖票 */ new Thread(()-\u0026gt;{ for (int i = 1; i \u0026lt;=300 ; i++) { token.sale(); } },\u0026#34;A\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 1; i \u0026lt;=300 ; i++) { token.sale(); } },\u0026#34;B\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 1; i \u0026lt;=300 ; i++) { token.sale(); } },\u0026#34;C\u0026#34;).start(); } } class Token{ //资源类 Lock lock = new ReentrantLock(); private int ticket=300; //总票数 public void sale(){ try { lock.lock(); if (ticket\u0026gt;0){ ticket--; System.out.println(Thread.currentThread().getName()+\u0026#34;卖了一张票，当前还有\u0026#34;+ ticket + \u0026#34;票\u0026#34;); } } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } } Synchronized 和 Lock 区别 synchronized是Java的关键字，而Lock是Java的一个类 synchronized是自动释放锁的（线程正常执行完毕会释放锁，线程执行出现异常也会释放锁），而Lock需要在finally手动释放锁（即调用unlock()方法），否则或造成死锁 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1 阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平也可非公平（两者皆可） Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题 生产者消费者 生产者和消费者 synchroinzed 版 /** * 现在四个线程，可以操作初始值为0的一个变量 * 实现两个线程对该变量 + 1，两个线程对该变量 -1 * 实现交替30次 */ public class ProducerAndConsumer_syn { public static void main(String[] args) { Data1 data = new Data1(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt;30 ; i++) { data.consumer(); } },\u0026#34;A\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt;30 ; i++) { data.producer(); } },\u0026#34;B\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt;30 ; i++) { data.consumer(); } },\u0026#34;C\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt;30 ; i++) { data.producer(); } },\u0026#34;D\u0026#34;).start(); } } class Data1{ private int number = 0; public synchronized void producer(){ // if (number!=0){ //用if判断会出现虚假唤醒 while (number!=0){\t//如果为1，则生产者线程等待，否则唤醒 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } number++; System.out.println(Thread.currentThread().getName()+\u0026#34;===\u0026gt;\u0026#34;+number); this.notifyAll(); } public synchronized void consumer(){ // if (number==0){ //用if判断会出现虚假唤醒 while (number==0){\t//如果为0，则消费者线程等待，否则唤醒 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } number--; System.out.println(Thread.currentThread().getName()+\u0026#34;===\u0026gt;\u0026#34;+number); this.notifyAll(); } } 关于虚假唤醒\n因为if只会判断一次，当其它线程唤醒等待线程时，在停留在if作用域的线程被唤醒，不会再次判断，当有多个线程时，这种情况会引起虚假唤醒现象，即没有满足唤醒条件也会被唤醒，所以改用while循环，重复判断，以防脱离判断条件\n新版生产者和消费者写法（Lock版） import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * 现在四个线程，可以操作初始值为0的一个变量 * 实现两个线程对该变量 + 1，两个线程对该变量 -1 * 实现交替10次 */ public class ProducerAndConsumer_Lock { public static void main(String[] args) { Data2 data = new Data2(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt;10 ; i++) { data.consumer(); } },\u0026#34;A\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt;10 ; i++) { data.producer(); } },\u0026#34;B\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt;10 ; i++) { data.consumer(); } },\u0026#34;C\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt;10 ; i++) { data.producer(); } },\u0026#34;D\u0026#34;).start(); } } class Data2{ private int number = 0; Lock lock =new ReentrantLock(); Condition condition =lock.newCondition(); public void producer(){ lock.lock(); try { while (number!=0){ //如果为1，则生产者线程等待，否则唤醒 condition.await();\t//让线程等待 } number++; System.out.println(Thread.currentThread().getName()+\u0026#34;===\u0026gt;\u0026#34;+number); condition.signalAll(); } catch (Exception e) { e.printStackTrace();\t//唤醒其它线程（即唤醒消费者线程） } finally { lock.unlock(); } } public void consumer(){ lock.lock(); try { while (number==0){ //如果为0，则消费者线程等待，否则唤醒 condition.await();\t//让线程等待 } number--; System.out.println(Thread.currentThread().getName()+\u0026#34;===\u0026gt;\u0026#34;+number); condition.signalAll();\t//唤醒其它线程（即唤醒生产者线程） } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } } Lock指定通知顺序唤醒访问 import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * 多线程之间按顺序调用，实现 A-\u0026gt;B-\u0026gt;C * 三个线程启动， * A 打印10次，B 打印10次,C 打印10次，依次循环 */ public class Lock_Condition { public static void main(String[] args) { Data3 data3 = new Data3(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { data3.A(); } },\u0026#34;AAA\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { data3.B(); } },\u0026#34;BBB\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { data3.C(); } },\u0026#34;CCC\u0026#34;).start(); } } class Data3{ private int number = 1 ; Lock lock = new ReentrantLock(); Condition condition1 = lock.newCondition(); Condition condition2 = lock.newCondition(); Condition condition3 = lock.newCondition(); public void A() { lock.lock(); try { while (number !=1){\t//如果不为1，则线程等待 condition1.await(); } number = 2; System.out.println(Thread.currentThread().getName()+\u0026#34;===\u0026gt;AAA\u0026#34;); condition2.signal();\t//唤醒B线程，即线程中 变量number为2的 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public void B(){ lock.lock(); try { while (number != 2){\t//如果不为2，则线程等待 condition2.await(); } number = 3; System.out.println(Thread.currentThread().getName()+\u0026#34;===\u0026gt;BBB\u0026#34;); condition3.signal(); //唤醒C线程，即线程中 变量number为3的 } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } public void C(){ lock.lock(); try { while (number!=3){\t//如果不为3，则线程等待 condition3.await(); } number = 1; System.out.println(Thread.currentThread().getName()+\u0026#34;===\u0026gt;CCC\u0026#34;); condition1.signal();//唤醒A线程，即线程中 变量number为1的 } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } } 集合类不安全 List 单线程环境下：\n多线程环境下：\nimport java.util.*; import java.util.concurrent.CopyOnWriteArrayList; /** * 因为多线程情况下，list是不安全的 * add()方法没有加锁，导致会抛java.util.ConcurrentModificationException异常 * 解决方案，换一个集合类 * 1、List\u0026lt;String\u0026gt; list = new Vector\u0026lt;\u0026gt;(); JDK1.0就存在了 * 2、List\u0026lt;String\u0026gt; list = Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;()); 通过集合工具类转换得到一个安全类 * 3、List\u0026lt;String\u0026gt; list = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); JUC包下提供的一个类，写入时复制 */ public class ListTest03 { public static void main(String[] args) { List\u0026lt;String\u0026gt; list = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 30; i++) { new Thread(()-\u0026gt;{ list.add(UUID.randomUUID().toString().substring(0,8)); System.out.println(list); }).start(); } } } 写入时复制（CopyOnWrite）思想\n写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种优化策略。其核心思想 是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共 同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用 副本（private copy）给该调用者，而其他调用者所见到的初的资源仍然保持不变。这过程对其他的 调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本 （private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。 读写分离，写时复制出一个新的数组，完成插入、修改或者移除操作后将新数组赋值给array\nCopyOnWriteArrayList为什么并发安全且性能比Vector好\n我知道Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得 锁，性能就会大大下降，而CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性 能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况。\nSet 多线程环境下：\n/** * 多线程情况下，set是不安全的 * add()方法没有加锁，导致会抛java.util.ConcurrentModificationException异常 * 解决方案，换一个集合类 * 1、Set\u0026lt;String\u0026gt; set = Collections.synchronizedSet(new HashSet\u0026lt;\u0026gt;()); 通过集合工具类转换得到一个安全类 * 2、Set\u0026lt;String\u0026gt; set = new CopyOnWriteArraySet\u0026lt;\u0026gt;(); JUC包下提供的一个类，写入时复制 */ public class SetTest02 { public static void main(String[] args) { Set\u0026lt;String\u0026gt; set = new CopyOnWriteArraySet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 30; i++) { set.add(UUID.randomUUID().toString().substring(0,8)); System.out.println(set); } } } 另外还有一点，HashSet底层就是HashMap，JDK源码如下：\n通过源码可以看出，HashSet底层是创建了一个HashMap，Key就是存放HashSet的值，也就是通过HashMap的key机制，来去除重复值的，而key对应的value就是一个叫PRESENT的常量\nMap HashMap底层就是数组+链表+红黑树（JDK1.8开始，当链表长度大于8时，链表自动转为红黑树，这是为查询值时做的一个优化）\n从JDK1.8源码可以看出，在创建时HashMap可以指定它的长度（即容量）和加载因子，否则就是默认的16长度和0.75加载因子\r多线程环境下：\nimport java.util.Map; import java.util.UUID; import java.util.concurrent.ConcurrentHashMap; public class HashMapTest02 { public static void main(String[] args) { /** *多线程环境下，map同样是不安全的 * put方法并没有加锁，导致也抛出同样的java.util.ConcurrentModificationException异常 * 解决办法，也是换一个集合类 * Map\u0026lt;String, String\u0026gt; map = new Hashtable\u0026lt;\u0026gt;(); JDK1.0就有，效率不怎么，因为它是锁全部 * Map\u0026lt;String, String\u0026gt; map = Collections.synchronizedMap(new HashMap\u0026lt;\u0026gt;()); * Map\u0026lt;String, String\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;(); */ Map\u0026lt;String, String\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 30; i++) { new Thread(()-\u0026gt;{ map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,8)); System.out.println(map); },String.valueOf(i)).start(); } } } 读写锁 多个线程同时读同一个资源类时，是不会出现任何问题的，但是实际情况往往是读写并发的，也就说读写资源类是同时进行的。\n如果资源类不进行加锁的话，会产生错误：\n发现写入时，未完成写入，就有其它线程也进行写入，这种是会产生安全问题的\nReentrantReadWriteLock(读写锁) import java.util.HashMap; import java.util.Map; import java.util.UUID; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReentrantReadWriteTest02 { public static void main(String[] args) { MyCacheLock myCacheLock = new MyCacheLock(); //开启10个线程去写 for (int i = 0; i \u0026lt; 10; i++) { final int temp = i; new Thread(()-\u0026gt;{ myCacheLock.put(temp+\u0026#34;\u0026#34;, UUID.randomUUID().toString().substring(0,5)); },\u0026#34;写\u0026#34;+i).start(); } //开启10个线程去读 for (int i = 0; i \u0026lt; 10; i++) { final int temp = i; new Thread(()-\u0026gt;{ myCacheLock.get(temp+\u0026#34;\u0026#34;); },\u0026#34;读\u0026#34;+i).start(); } } } class MyCacheLock{ private volatile Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); //读写锁 public void put(String key , String value){ readWriteLock.writeLock().lock(); //加写锁 try { System.out.println(Thread.currentThread().getName()+\u0026#34;号线程==》Key值：\u0026#34;+ key +\u0026#34; 开始写入\u0026#34;); map.put(key,value); System.out.println(Thread.currentThread().getName()+\u0026#34;号线程==》写入成功\u0026#34;); } catch (Exception e) { e.printStackTrace(); } finally { readWriteLock.writeLock().unlock(); } } public void get(String key){ readWriteLock.readLock().lock(); //加读锁 try { System.out.println(Thread.currentThread().getName()+\u0026#34;号线程开始读取Key值对应的value值\u0026#34;); String result = map.get(key); System.out.println(Thread.currentThread().getName()+\u0026#34;读取结果：\u0026#34;+result); } catch (Exception e) { e.printStackTrace(); } finally { readWriteLock.readLock().unlock(); } } } 线程池 JDK官方提供三种创建线程池的方法 线程池中只创建一个线程 newSingleThreadExecutor() import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolTest01 { public static void main(String[] args) { //newSingleThreadExecutor创建只有一个线程 ExecutorService threadpool = Executors.newSingleThreadExecutor(); try { for (int i = 0; i \u0026lt; 10; i++) { //只有一个线程受理，来执行10个任务 threadpool.execute(()-\u0026gt;{ System.out.println(Thread.currentThread().getName()+\u0026#34;执行业务\u0026#34;); }); } } catch (Exception e) { e.printStackTrace(); } finally { threadpool.shutdown(); //关闭线程池 } } } 线程池中创建固定数目的多个线程 newFixedThreadPool（） import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolTest02 { public static void main(String[] args) { //线程池中创建5个线程 ExecutorService threadPool = Executors.newFixedThreadPool(5); try { for (int i = 0; i \u0026lt; 20; i++) { //只有五个线程来受理，来执行20个任务 threadPool.execute(()-\u0026gt;{ System.out.println(Thread.currentThread().getName()+\u0026#34;执行业务\u0026#34;); }); } } catch (Exception e) { e.printStackTrace(); } finally { threadPool.shutdown(); //关闭线程池 } } } 线程池中创建不固定数目的多个线程 newCachedThreadPool() import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolTest03 { public static void main(String[] args) { //创建线程池，池中线程数是不固定的，线程具体是伸缩的 ExecutorService threadPool = Executors.newCachedThreadPool(); try { for (int i = 0; i \u0026lt; 20 ; i++) { //有N个线程受理，来执行20个任务 threadPool.execute(()-\u0026gt;{ System.out.println(Thread.currentThread().getName()+\u0026#34;执行业务\u0026#34;); }); } } catch (Exception e) { e.printStackTrace(); } finally { threadPool.shutdown(); //关闭线程池 } } } 自定义线程池 ThreadPoolExecutor() 通过查看JDK源码，发现三种创建线程池的方法都是调用了new ThreadPoolExecutor(七个参数)\n三种创建线程池方法源码如下：\n查看ThreadPoolExecutor()方法源码如下：\r发现该方法有七个参数\nint corePoolSize ：核心线程数量。当创建线程池后，线程池中线程数是为0的，当有任务进来时，才开始创建线程执行任务，而线程池空闲时，会维护一个最小线程数量，即使这些线程数是空闲状态，也不会销毁它们，除非设置了allowCoreThreadTimeOut，而这个最小线程数就是corePoolSize\n**int maximumPoolSize ：**最大线程数量。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize来指定\nlong keepAliveTime ：线程保留的时间。一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定\n**TimeUnit unit ： ** keepAliveTime的计量单位\nTimeUnit.DAYS; //天 TimeUnit.HOURS; //小时 TimeUnit.MINUTES; //分钟 TimeUnit.SECONDS; //秒 TimeUnit.MILLISECONDS; //毫秒 TimeUnit.MICROSECONDS; //微妙 TimeUnit.NANOSECONDS; //纳秒 **BlockingQueue\u0026lt; Runnable \u0026gt; workQueue ：**阻塞队列，存储等待执行的任务。\n新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：\nArrayBlockingQueue\n基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。\nLinkedBlockingQuene\n基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。\nSynchronousQuene\n一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。\nPriorityBlockingQueue\n具有优先级的无界阻塞队列，优先级通过参数Comparator实现。\n**ThreadFactory threadFactory ：**线程工厂，用来创建线程，一般默认即可。可以用来设定线程名等等\nRejectedExecutionHandler handler ： 拒绝策略，队列已满，而且任务量大于大线程的异常处理策略\nThreadPoolExecutor.AbortPolicy; //丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：//也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：//抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列（重复此过程） ThreadPoolExecutor.CallerRunsPolicy：//由调用线程处理该任务 举例记忆 ，银行窗口办理业务的过程非常适合理解这七个参数\n测试：\nimport java.util.concurrent.*; public class MyThreadPoolTest { public static void main(String[] args) { /** * 创建自定义线程池 */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 4, 8, 30L, TimeUnit.SECONDS, new LinkedBlockingDeque\u0026lt;\u0026gt;(6), Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardOldestPolicy()); try { for (int i = 0; i \u0026lt; 10; i++) { threadPoolExecutor.execute(()-\u0026gt;{ System.out.println(Thread.currentThread().getName()+\u0026#34;执行业务\u0026#34;); }); } } catch (Exception e) { e.printStackTrace(); } finally { threadPoolExecutor.shutdown(); //关闭线程池 } } } 自定义线程池最大容量为：最大线程数（maximumPoolSize ） + 阻塞队列容量(workQueue)\nJUC的常用类 Semaphore类（信号量） import java.util.concurrent.Semaphore; import java.util.concurrent.TimeUnit; public class SemaphoreTest { /** * 三个车位，九个人去抢 * 根据juc的辅助类Semaphore限流实现 * @param args */ public static void main(String[] args) { //规定只能进去三个 Semaphore semaphore = new Semaphore(3); for (int i = 0; i \u0026lt;9 ; i++) { //开启九个线程去抢三个车位 new Thread(()-\u0026gt;{ try { semaphore.acquire();//得到 System.out.println(Thread.currentThread().getName()+\u0026#34;得到停车位\u0026#34;); TimeUnit.SECONDS.sleep(3); //停了三秒，然后离开车位，留给后面的人进来 System.out.println(Thread.currentThread().getName()+\u0026#34;离开停车位\u0026#34;); } catch (InterruptedException e) { e.printStackTrace(); }finally { semaphore.release();//释放 } },String.valueOf(i)).start(); } } } 在上述测试中，semaphore定义了两个操作\nacquire（获取）\n当一个线程调用acquire()方法操作时\n当前线程要么成功获取到信号量（即信号量-1，被占了一个） 要么等待其它线程释放信号量，或者一直等待到超时 release（释放）\n当线程调用release()方法时，则当前线程会释放信号量（即信号量+1），以便其它等待的线程拿到信号量\nCountDowLath类（倒计时记数器） import java.util.concurrent.CountDownLatch; public class CountDownLatchTest { public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(5); for (int i = 0; i \u0026lt; 6; i++) { new Thread(()-\u0026gt;{ countDownLatch.countDown();//计数减一 System.out.println(Thread.currentThread().getName()+\u0026#34;线程执行完成\u0026#34;); },String.valueOf(i)).start(); } countDownLatch.await(); //当前线程阻塞，等待计数器归零 System.out.println(Thread.currentThread().getName()+\u0026#34;END\u0026#34;); } } 在上述测试中，countdowlath类有两个方法\ncountDown()\n当一个或多个线程调用countDown()方法时，计数器会减1，且线程不会被阻塞\nawait()\n当一个线程或多个线程调用await()方法，调用该方法的线程会被阻塞，直到计数器归零，阻塞的线程才会重新被唤醒继续往下执行\n从执行结果可以看出，其它子线程调用countDown()并没有被阻塞而是继续执行直至完毕，但调用await()方法的main主线却被阻塞，直到计数器归零才重新执行\nCyclicBarrier类 import java.util.concurrent.BrokenBarrierException; import java.util.concurrent.CyclicBarrier; public class CyclicBarrierTest { public static void main(String[] args) { CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()-\u0026gt;{ System.out.println(\u0026#34;出来吧！神龙\u0026#34;); }); for (int i = 1; i \u0026lt;= 7; i++) { final int temp = i; //JDK1.8之前要用final修饰 new Thread(()-\u0026gt;{ System.out.println(Thread.currentThread().getName()+\u0026#34;线程==》得到了第\u0026#34;+ temp +\u0026#34;颗龙珠\u0026#34;); try { cyclicBarrier.await(); //让线程等待 } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } System.out.println(); },String.valueOf(i)).start(); } } } CyclicBarrier与上面计数器(CountDowLath)作用相反，当等待线程达到指定数目，则释放等待的线程，并执行对应的内容，譬如上述测试，集齐七颗龙珠召唤神龙\n","permalink":"http://shaoyi.cc/posts/blog/%E6%9D%82%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/","summary":"Java锁 独占锁（写锁）： 指该锁一次只能被一个线程锁持有。对于ReentranrLock和 Synchronized 而言都是独 占锁。 共享锁（读锁）： 该锁可被多个线程","title":"Java多线程笔记"},{"content":"Explain详解 explain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra\nid selcet查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序，大概分为三种情况：\nid相同时，执行顺序由上至下 id不同时，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 id相同又不相同，同时存在 id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行 select_type 查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询，类型大概为：\nSIMPLE\n简单的select查询语句，查询语句不使用UNION或子查询\nPRIMARY\n查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY\nSUBQUERY\n在select或where列表中包含的子查询\nDERIVED\n在from列表中包含的子查询被标记为DERIVED(衍生表)，MySQL会递归执行这些子查询，把结果放在临时表里。\nUNION\n若第二个select出现在UNION之后，会被标记为UNION；若UNION包含在from子句的子查询中，外层select将被标记为：DERIVED\n**UNION RESULT **\nUNION的结果\ntable 显示这一行的数据是关于哪张表的，有时不是真实的表名字,看到的是derivedx(x是个数字,我的理解是第几步执行的结果，也就是id数)\n譬如下面的例子：\nmysql\u0026gt; explain select * from (select * from ( select * from t1 where id=2602) a) b; +----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | | | 2 | DERIVED | \u0026lt;derived3\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | | | 3 | DERIVED | t1 | const | PRIMARY,idx_t1_id | PRIMARY | 4 | | 1 | | +----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+ type 表示MySQL在表中找到所需行的方式，又称“访问类型排列”。\n常用的类型有： ALL, index, range, ref, eq_ref, const, system（从左到右，性能从差到好）\n即：ALL \u0026lt; index \u0026lt; range \u0026lt; ref \u0026lt; eq_ref \u0026lt; const \u0026lt; system\n一般来说，得保证查询至少达到range级别，最好能达到ref\nALL： Full Table Scan， MySQL将遍历全表以找到匹配的行\nindex： Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。\nrange： 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、\u0026lt;、\u0026gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引\nref： 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体\neq_ref： 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件\nconst： 表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配到一行数据，所以就很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量\nsystem： 是const类型的特例，当查询的表只有一行的情况下，平时不会出现，这个可以忽略不计\npossible_keys 显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用\nKey 实际使用的索引。如果为NULL，则没有使用索引。查询中若使用了覆盖索引，则该索引和查询的select字段重叠\nkey_len 表示索引使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。\nkey_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的\nref 显示索引得哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值\nrows 根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数\nExtra 包含不适合在其他列中显示但十分重要的额外信息\nUsing filesort： 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”\nUsing temporary： 使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by 和分组查询 group by\nUsing index ： 表示相应的select操作中使用了覆盖索引（Covering Index）,避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。\nUsing where： 表明使用了where过滤\nUsing join buffer： 使用了连接缓存\nimpossible where： where子句的值总是false，不能用来获取任何元组\nselect tables optimized away：\t在没有group by 子句的情况下，基于索引优化min/max操作或者对于MyISAM 存储引擎优化count(*)操作，不必等到执行阶段再进行计算，查询执行计划生产的阶段即完成优化\ndistinct： 优化distinct操作，在找到第一匹配的元组后即停止找同样值得动作\n","permalink":"http://shaoyi.cc/posts/blog/%E6%9D%82%E8%AE%B0/mysql/mysql%E4%B9%8Bexplain/","summary":"Explain详解 explain出来的信息有10列，分别是id、select_type、table、type、possible_keys、k","title":"Mysql之Explain详解"}]